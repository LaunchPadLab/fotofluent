/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(305);


/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(3);
	
	__webpack_require__(294);
	
	__webpack_require__(296);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(4);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(56);
	__webpack_require__(58);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(69);
	__webpack_require__(71);
	__webpack_require__(73);
	__webpack_require__(75);
	__webpack_require__(77);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(82);
	__webpack_require__(86);
	__webpack_require__(88);
	__webpack_require__(90);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(96);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(104);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(112);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(194);
	__webpack_require__(196);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(212);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(292);
	__webpack_require__(293);
	module.exports = __webpack_require__(10);

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var global = __webpack_require__(5),
	    has = __webpack_require__(6),
	    DESCRIPTORS = __webpack_require__(7),
	    $export = __webpack_require__(9),
	    redefine = __webpack_require__(19),
	    META = __webpack_require__(23).KEY,
	    $fails = __webpack_require__(8),
	    shared = __webpack_require__(24),
	    setToStringTag = __webpack_require__(25),
	    uid = __webpack_require__(20),
	    wks = __webpack_require__(26),
	    wksExt = __webpack_require__(27),
	    wksDefine = __webpack_require__(28),
	    keyOf = __webpack_require__(30),
	    enumKeys = __webpack_require__(43),
	    isArray = __webpack_require__(46),
	    anObject = __webpack_require__(13),
	    toIObject = __webpack_require__(33),
	    toPrimitive = __webpack_require__(17),
	    createDesc = __webpack_require__(18),
	    _create = __webpack_require__(47),
	    gOPNExt = __webpack_require__(50),
	    $GOPD = __webpack_require__(52),
	    $DP = __webpack_require__(12),
	    $keys = __webpack_require__(31),
	    gOPD = $GOPD.f,
	    dP = $DP.f,
	    gOPN = gOPNExt.f,
	    $Symbol = global.Symbol,
	    $JSON = global.JSON,
	    _stringify = $JSON && $JSON.stringify,
	    PROTOTYPE = 'prototype',
	    HIDDEN = wks('_hidden'),
	    TO_PRIMITIVE = wks('toPrimitive'),
	    isEnum = {}.propertyIsEnumerable,
	    SymbolRegistry = shared('symbol-registry'),
	    AllSymbols = shared('symbols'),
	    OPSymbols = shared('op-symbols'),
	    ObjectProto = Object[PROTOTYPE],
	    USE_NATIVE = typeof $Symbol == 'function',
	    QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function get() {
	      return dP(this, 'a', { value: 7 }).a;
	    }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function wrap(tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
	  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    }return setSymbolDesc(it, key, D);
	  }return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P)),
	      i = 0,
	      l = keys.length,
	      key;
	  while (l > i) {
	    $defineProperty(it, key = keys[i++], P[key]);
	  }return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it)),
	      result = [],
	      i = 0,
	      key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  }return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto,
	      names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
	      result = [],
	      i = 0,
	      key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  }return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function _Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function $set(value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(51).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(45).f = $propertyIsEnumerable;
	  __webpack_require__(44).f = $getOwnPropertySymbols;
	
	  if (DESCRIPTORS && !__webpack_require__(29)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
	
	for (var symbols =
	// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), i = 0; symbols.length > i;) {
	  wks(symbols[i++]);
	}for (var symbols = $keys(wks.store), i = 0; symbols.length > i;) {
	  wksDefine(symbols[i++]);
	}$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function _for(key) {
	    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key) {
	    if (isSymbol(key)) return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function useSetter() {
	    setter = true;
	  },
	  useSimple: function useSimple() {
	    setter = false;
	  }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    var args = [it],
	        i = 1,
	        replacer,
	        $replacer;
	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }replacer = args[1];
	    if (typeof replacer == 'function') $replacer = replacer;
	    if ($replacer || !isArray(replacer)) replacer = function replacer(key, value) {
	      if ($replacer) value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';
	
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	"use strict";
	
	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(8)(function () {
	  return Object.defineProperty({}, 'a', { get: function get() {
	      return 7;
	    } }).a != 7;
	});

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    core = __webpack_require__(10),
	    hide = __webpack_require__(11),
	    redefine = __webpack_require__(19),
	    ctx = __webpack_require__(21),
	    PROTOTYPE = 'prototype';
	
	var $export = function $export(type, name, source) {
	  var IS_FORCED = type & $export.F,
	      IS_GLOBAL = type & $export.G,
	      IS_STATIC = type & $export.S,
	      IS_PROTO = type & $export.P,
	      IS_BIND = type & $export.B,
	      target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
	      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
	      expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
	      key,
	      own,
	      out,
	      exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1; // forced
	$export.G = 2; // global
	$export.S = 4; // static
	$export.P = 8; // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	$export.U = 64; // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	'use strict';
	
	var core = module.exports = { version: '2.4.0' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var dP = __webpack_require__(12),
	    createDesc = __webpack_require__(18);
	module.exports = __webpack_require__(7) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var anObject = __webpack_require__(13),
	    IE8_DOM_DEFINE = __webpack_require__(15),
	    toPrimitive = __webpack_require__(17),
	    dP = Object.defineProperty;
	
	exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) {/* empty */}
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var isObject = __webpack_require__(14);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = function (it) {
	  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = !__webpack_require__(7) && !__webpack_require__(8)(function () {
	  return Object.defineProperty(__webpack_require__(16)('div'), 'a', { get: function get() {
	      return 7;
	    } }).a != 7;
	});

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var isObject = __webpack_require__(14),
	    document = __webpack_require__(5).document
	// in old IE typeof document.createElement is 'object'
	,
	    is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    hide = __webpack_require__(11),
	    has = __webpack_require__(6),
	    SRC = __webpack_require__(20)('src'),
	    TO_STRING = 'toString',
	    $toString = Function[TO_STRING],
	    TPL = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(10).inspectSource = function (it) {
	  return $toString.call(it);
	};
	
	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) has(val, 'name') || hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === global) {
	    O[key] = val;
	  } else {
	    if (!safe) {
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if (O[key]) O[key] = val;else hide(O, key, val);
	    }
	  }
	  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	var id = 0,
	    px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// optional / simple context binding
	var aFunction = __webpack_require__(22);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };
	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };
	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }
	  return function () /* ...args */{
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var META = __webpack_require__(20)('meta'),
	    isObject = __webpack_require__(14),
	    has = __webpack_require__(6),
	    setDesc = __webpack_require__(12).f,
	    id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(8)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function setMeta(it) {
	  setDesc(it, META, { value: {
	      i: 'O' + ++id, // object ID
	      w: {} // weak collections IDs
	    } });
	};
	var fastKey = function fastKey(it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	    // return object ID
	  }return it[META].i;
	};
	var getWeak = function getWeak(it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	    // return hash weak collections IDs
	  }return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function onFreeze(it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    SHARED = '__core-js_shared__',
	    store = global[SHARED] || (global[SHARED] = {});
	module.exports = function (key) {
	  return store[key] || (store[key] = {});
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var def = __webpack_require__(12).f,
	    has = __webpack_require__(6),
	    TAG = __webpack_require__(26)('toStringTag');
	
	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var store = __webpack_require__(24)('wks'),
	    uid = __webpack_require__(20),
	    _Symbol = __webpack_require__(5).Symbol,
	    USE_SYMBOL = typeof _Symbol == 'function';
	
	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.f = __webpack_require__(26);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    core = __webpack_require__(10),
	    LIBRARY = __webpack_require__(29),
	    wksExt = __webpack_require__(27),
	    defineProperty = __webpack_require__(12).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = false;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var getKeys = __webpack_require__(31),
	    toIObject = __webpack_require__(33);
	module.exports = function (object, el) {
	  var O = toIObject(object),
	      keys = getKeys(O),
	      length = keys.length,
	      index = 0,
	      key;
	  while (length > index) {
	    if (O[key = keys[index++]] === el) return key;
	  }
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(32),
	    enumBugKeys = __webpack_require__(42);
	
	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var has = __webpack_require__(6),
	    toIObject = __webpack_require__(33),
	    arrayIndexOf = __webpack_require__(37)(false),
	    IE_PROTO = __webpack_require__(41)('IE_PROTO');
	
	module.exports = function (object, names) {
	  var O = toIObject(object),
	      i = 0,
	      result = [],
	      key;
	  for (key in O) {
	    if (key != IE_PROTO) has(O, key) && result.push(key);
	  } // Don't enum bug & hidden keys
	  while (names.length > i) {
	    if (has(O, key = names[i++])) {
	      ~arrayIndexOf(result, key) || result.push(key);
	    }
	  }return result;
	};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(34),
	    defined = __webpack_require__(36);
	module.exports = function (it) {
	  return IObject(defined(it));
	};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(35);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	"use strict";
	
	var toString = {}.toString;
	
	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	"use strict";
	
	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(33),
	    toLength = __webpack_require__(38),
	    toIndex = __webpack_require__(40);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this),
	        length = toLength(O.length),
	        index = toIndex(fromIndex, length),
	        value;
	    // Array#includes uses SameValueZero equality algorithm
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	      // Array#toIndex ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if (IS_INCLUDES || index in O) {
	        if (O[index] === el) return IS_INCLUDES || index || 0;
	      }
	    }return !IS_INCLUDES && -1;
	  };
	};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 7.1.15 ToLength
	var toInteger = __webpack_require__(39),
	    min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	"use strict";
	
	// 7.1.4 ToInteger
	var ceil = Math.ceil,
	    floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var toInteger = __webpack_require__(39),
	    max = Math.max,
	    min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var shared = __webpack_require__(24)('keys'),
	    uid = __webpack_require__(20);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	'use strict';
	
	// IE 8- don't enum bug keys
	module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(31),
	    gOPS = __webpack_require__(44),
	    pIE = __webpack_require__(45);
	module.exports = function (it) {
	  var result = getKeys(it),
	      getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it),
	        isEnum = pIE.f,
	        i = 0,
	        key;
	    while (symbols.length > i) {
	      if (isEnum.call(it, key = symbols[i++])) result.push(key);
	    }
	  }return result;
	};

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(35);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(13),
	    dPs = __webpack_require__(48),
	    enumBugKeys = __webpack_require__(42),
	    IE_PROTO = __webpack_require__(41)('IE_PROTO'),
	    Empty = function Empty() {/* empty */},
	    PROTOTYPE = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var _createDict = function createDict() {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(16)('iframe'),
	      i = enumBugKeys.length,
	      lt = '<',
	      gt = '>',
	      iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(49).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  _createDict = iframeDocument.F;
	  while (i--) {
	    delete _createDict[PROTOTYPE][enumBugKeys[i]];
	  }return _createDict();
	};
	
	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = _createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var dP = __webpack_require__(12),
	    anObject = __webpack_require__(13),
	    getKeys = __webpack_require__(31);
	
	module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties),
	      length = keys.length,
	      i = 0,
	      P;
	  while (length > i) {
	    dP.f(O, P = keys[i++], Properties[P]);
	  }return O;
	};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(5).document && document.documentElement;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(33),
	    gOPN = __webpack_require__(51).f,
	    toString = {}.toString;
	
	var windowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function getWindowNames(it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(32),
	    hiddenKeys = __webpack_require__(42).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var pIE = __webpack_require__(45),
	    createDesc = __webpack_require__(18),
	    toIObject = __webpack_require__(33),
	    toPrimitive = __webpack_require__(17),
	    has = __webpack_require__(6),
	    IE8_DOM_DEFINE = __webpack_require__(15),
	    gOPD = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) {/* empty */}
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(47) });

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperty: __webpack_require__(12).f });

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperties: __webpack_require__(48) });

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(33),
	    $getOwnPropertyDescriptor = __webpack_require__(52).f;
	
	__webpack_require__(57)('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(9),
	    core = __webpack_require__(10),
	    fails = __webpack_require__(8);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY],
	      exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () {
	    fn(1);
	  }), 'Object', exp);
	};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(59),
	    $getPrototypeOf = __webpack_require__(60);
	
	__webpack_require__(57)('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(36);
	module.exports = function (it) {
	  return Object(defined(it));
	};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(6),
	    toObject = __webpack_require__(59),
	    IE_PROTO = __webpack_require__(41)('IE_PROTO'),
	    ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }return O instanceof Object ? ObjectProto : null;
	};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(59),
	    $keys = __webpack_require__(31);
	
	__webpack_require__(57)('keys', function () {
	  return function keys(it) {
	    return $keys(toObject(it));
	  };
	});

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(57)('getOwnPropertyNames', function () {
	  return __webpack_require__(50).f;
	});

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(14),
	    meta = __webpack_require__(23).onFreeze;
	
	__webpack_require__(57)('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(14),
	    meta = __webpack_require__(23).onFreeze;
	
	__webpack_require__(57)('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(14),
	    meta = __webpack_require__(23).onFreeze;
	
	__webpack_require__(57)('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(14);
	
	__webpack_require__(57)('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(14);
	
	__webpack_require__(57)('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(14);
	
	__webpack_require__(57)('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(9);
	
	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(70) });

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	
	var getKeys = __webpack_require__(31),
	    gOPS = __webpack_require__(44),
	    pIE = __webpack_require__(45),
	    toObject = __webpack_require__(59),
	    IObject = __webpack_require__(34),
	    $assign = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(8)(function () {
	  var A = {},
	      B = {},
	      S = Symbol(),
	      K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) {
	    B[k] = k;
	  });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  // eslint-disable-line no-unused-vars
	  var T = toObject(target),
	      aLen = arguments.length,
	      index = 1,
	      getSymbols = gOPS.f,
	      isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]),
	        keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
	        length = keys.length,
	        j = 0,
	        key;
	    while (length > j) {
	      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	    }
	  }return T;
	} : $assign;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', { is: __webpack_require__(72) });

/***/ }),
/* 72 */
/***/ (function(module, exports) {

	"use strict";
	
	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y) {
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(74).set });

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14),
	    anObject = __webpack_require__(13);
	var check = function check(O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	  function (test, buggy, set) {
	    try {
	      set = __webpack_require__(21)(Function.call, __webpack_require__(52).f(Object.prototype, '__proto__').set, 2);
	      set(test, []);
	      buggy = !(test instanceof Array);
	    } catch (e) {
	      buggy = true;
	    }
	    return function setPrototypeOf(O, proto) {
	      check(O, proto);
	      if (buggy) O.__proto__ = proto;else set(O, proto);
	      return O;
	    };
	  }({}, false) : undefined),
	  check: check
	};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	
	var classof = __webpack_require__(76),
	    test = {};
	test[__webpack_require__(26)('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  __webpack_require__(19)(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(35),
	    TAG = __webpack_require__(26)('toStringTag')
	// ES3 wrong here
	,
	    ARG = cof(function () {
	  return arguments;
	}()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function tryGet(it, key) {
	  try {
	    return it[key];
	  } catch (e) {/* empty */}
	};
	
	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	  // @@toStringTag case
	  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	  // builtinTag case
	  : ARG ? cof(O)
	  // ES3 arguments fallback
	  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(9);
	
	$export($export.P, 'Function', { bind: __webpack_require__(78) });

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var aFunction = __webpack_require__(22),
	    isObject = __webpack_require__(14),
	    invoke = __webpack_require__(79),
	    arraySlice = [].slice,
	    factories = {};
	
	var construct = function construct(F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) {
	      n[i] = 'a[' + i + ']';
	    }factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  }return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */) {
	  var fn = aFunction(this),
	      partArgs = arraySlice.call(arguments, 1);
	  var bound = function bound() /* args... */{
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	"use strict";
	
	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	                  var un = that === undefined;
	                  switch (args.length) {
	                                    case 0:
	                                                      return un ? fn() : fn.call(that);
	                                    case 1:
	                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
	                                    case 2:
	                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
	                                    case 3:
	                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
	                                    case 4:
	                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
	                  }return fn.apply(that, args);
	};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var dP = __webpack_require__(12).f,
	    createDesc = __webpack_require__(18),
	    has = __webpack_require__(6),
	    FProto = Function.prototype,
	    nameRE = /^\s*function ([^ (]*)/,
	    NAME = 'name';
	
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
	  configurable: true,
	  get: function get() {
	    try {
	      var that = this,
	          name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch (e) {
	      return '';
	    }
	  }
	});

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var isObject = __webpack_require__(14),
	    getPrototypeOf = __webpack_require__(60),
	    HAS_INSTANCE = __webpack_require__(26)('hasInstance'),
	    FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(12).f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
	    if (typeof this != 'function' || !isObject(O)) return false;
	    if (!isObject(this.prototype)) return O instanceof this;
	    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	    while (O = getPrototypeOf(O)) {
	      if (this.prototype === O) return true;
	    }return false;
	  } });

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $parseInt = __webpack_require__(83);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $parseInt = __webpack_require__(5).parseInt,
	    $trim = __webpack_require__(84).trim,
	    ws = __webpack_require__(85),
	    hex = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    defined = __webpack_require__(36),
	    fails = __webpack_require__(8),
	    spaces = __webpack_require__(85),
	    space = '[' + spaces + ']',
	    non = '\u200B\x85',
	    ltrim = RegExp('^' + space + space + '*'),
	    rtrim = RegExp(space + space + '*$');
	
	var exporter = function exporter(KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = fails(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ }),
/* 85 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $parseFloat = __webpack_require__(87);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $parseFloat = __webpack_require__(5).parseFloat,
	    $trim = __webpack_require__(84).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(85) + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3),
	      result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    has = __webpack_require__(6),
	    cof = __webpack_require__(35),
	    inheritIfRequired = __webpack_require__(89),
	    toPrimitive = __webpack_require__(17),
	    fails = __webpack_require__(8),
	    gOPN = __webpack_require__(51).f,
	    gOPD = __webpack_require__(52).f,
	    dP = __webpack_require__(12).f,
	    $trim = __webpack_require__(84).trim,
	    NUMBER = 'Number',
	    $Number = global[NUMBER],
	    Base = $Number,
	    proto = $Number.prototype
	// Opera ~12 has broken Object#toString
	,
	    BROKEN_COF = cof(__webpack_require__(47)(proto)) == NUMBER,
	    TRIM = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function toNumber(argument) {
	  var it = toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0),
	        third,
	        radix,
	        maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:case 98:
	          radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
	        case 79:case 111:
	          radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
	        default:
	          return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      }return parseInt(digits, radix);
	    }
	  }return +it;
	};
	
	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value,
	        that = this;
	    return that instanceof $Number
	    // check on 1..constructor(foo) case
	    && (BROKEN_COF ? fails(function () {
	      proto.valueOf.call(that);
	    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = __webpack_require__(7) ? gOPN(Base) : (
	  // ES3:
	  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	  // ES6 (in case, if modules with ES6 Number statics required before):
	  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
	    if (has(Base, key = keys[j]) && !has($Number, key)) {
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(19)(global, NUMBER, $Number);
	}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var isObject = __webpack_require__(14),
	    setPrototypeOf = __webpack_require__(74).set;
	module.exports = function (that, target, C) {
	  var P,
	      S = target.constructor;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  }return that;
	};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toInteger = __webpack_require__(39),
	    aNumberValue = __webpack_require__(91),
	    repeat = __webpack_require__(92),
	    $toFixed = 1..toFixed,
	    floor = Math.floor,
	    data = [0, 0, 0, 0, 0, 0],
	    ERROR = 'Number.toFixed: incorrect invocation!',
	    ZERO = '0';
	
	var multiply = function multiply(n, c) {
	  var i = -1,
	      c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function divide(n) {
	  var i = 6,
	      c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor(c / n);
	    c = c % n * 1e7;
	  }
	};
	var numToString = function numToString() {
	  var i = 6,
	      s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  }return s;
	};
	var pow = function pow(x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function log(x) {
	  var n = 0,
	      x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  }return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128..toFixed(0) !== '1000000000000000128') || !__webpack_require__(8)(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR),
	        f = toInteger(fractionDigits),
	        s = '',
	        m = ZERO,
	        e,
	        z,
	        j,
	        k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    }return m;
	  }
	});

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var cof = __webpack_require__(35);
	module.exports = function (it, msg) {
	  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
	  return +it;
	};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var toInteger = __webpack_require__(39),
	    defined = __webpack_require__(36);
	
	module.exports = function repeat(count) {
	  var str = String(defined(this)),
	      res = '',
	      n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (; n > 0; (n >>>= 1) && (str += str)) {
	    if (n & 1) res += str;
	  }return res;
	};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $fails = __webpack_require__(8),
	    aNumberValue = __webpack_require__(91),
	    $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.2 Number.isFinite(number)
	var $export = __webpack_require__(9),
	    _isFinite = __webpack_require__(5).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { isInteger: __webpack_require__(97) });

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(14),
	    floor = Math.floor;
	module.exports = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    return number != number;
	  }
	});

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.5 Number.isSafeInteger(number)
	var $export = __webpack_require__(9),
	    isInteger = __webpack_require__(97),
	    abs = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $parseFloat = __webpack_require__(87);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $parseInt = __webpack_require__(83);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(9),
	    log1p = __webpack_require__(105),
	    sqrt = Math.sqrt,
	    $acosh = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	&& Math.floor($acosh(Number.MAX_VALUE)) == 710
	// Tor Browser bug: Math.acosh(Infinity) -> NaN 
	&& $acosh(Infinity) == Infinity), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ }),
/* 105 */
/***/ (function(module, exports) {

	"use strict";
	
	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(9),
	    $asinh = Math.asinh;
	
	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(9),
	    $atanh = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(9),
	    sign = __webpack_require__(109);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ }),
/* 109 */
/***/ (function(module, exports) {

	"use strict";
	
	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x) {
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(9),
	    exp = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(9),
	    $expm1 = __webpack_require__(113);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	"use strict";
	
	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = !$expm1
	// Old FF bug
	|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	// Tor Browser bug
	|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.16 Math.fround(x)
	var $export = __webpack_require__(9),
	    sign = __webpack_require__(109),
	    pow = Math.pow,
	    EPSILON = pow(2, -52),
	    EPSILON32 = pow(2, -23),
	    MAX32 = pow(2, 127) * (2 - EPSILON32),
	    MIN32 = pow(2, -126);
	
	var roundTiesToEven = function roundTiesToEven(n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	$export($export.S, 'Math', {
	  fround: function fround(x) {
	    var $abs = Math.abs(x),
	        $sign = sign(x),
	        a,
	        result;
	    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if (result > MAX32 || result != result) return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(9),
	    abs = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2) {
	    // eslint-disable-line no-unused-vars
	    var sum = 0,
	        i = 0,
	        aLen = arguments.length,
	        larg = 0,
	        arg,
	        div;
	    while (i < aLen) {
	      arg = abs(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(9),
	    $imul = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff,
	        xn = +x,
	        yn = +y,
	        xl = UINT16 & xn,
	        yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { log1p: __webpack_require__(105) });

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { sign: __webpack_require__(109) });

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(9),
	    expm1 = __webpack_require__(113),
	    exp = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(9),
	    expm1 = __webpack_require__(113),
	    exp = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x),
	        b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toIndex = __webpack_require__(40),
	    fromCharCode = String.fromCharCode,
	    $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    // eslint-disable-line no-unused-vars
	    var res = [],
	        aLen = arguments.length,
	        i = 0,
	        code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (toIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
	    }return res.join('');
	  }
	});

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toIObject = __webpack_require__(33),
	    toLength = __webpack_require__(38);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw),
	        len = toLength(tpl.length),
	        aLen = arguments.length,
	        res = [],
	        i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    }return res.join('');
	  }
	});

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	
	__webpack_require__(84)('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $at = __webpack_require__(128)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(129)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0; // next index
	  // 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t,
	      index = this._i,
	      point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var toInteger = __webpack_require__(39),
	    defined = __webpack_require__(36);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that)),
	        i = toInteger(pos),
	        l = s.length,
	        a,
	        b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var LIBRARY = __webpack_require__(29),
	    $export = __webpack_require__(9),
	    redefine = __webpack_require__(19),
	    hide = __webpack_require__(11),
	    has = __webpack_require__(6),
	    Iterators = __webpack_require__(130),
	    $iterCreate = __webpack_require__(131),
	    setToStringTag = __webpack_require__(25),
	    getPrototypeOf = __webpack_require__(60),
	    ITERATOR = __webpack_require__(26)('iterator'),
	    BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	,
	    FF_ITERATOR = '@@iterator',
	    KEYS = 'keys',
	    VALUES = 'values';
	
	var returnThis = function returnThis() {
	  return this;
	};
	
	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function getMethod(kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS:
	        return function keys() {
	          return new Constructor(this, kind);
	        };
	      case VALUES:
	        return function values() {
	          return new Constructor(this, kind);
	        };
	    }return function entries() {
	      return new Constructor(this, kind);
	    };
	  };
	  var TAG = NAME + ' Iterator',
	      DEF_VALUES = DEFAULT == VALUES,
	      VALUES_BUG = false,
	      proto = Base.prototype,
	      $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
	      $default = $native || getMethod(DEFAULT),
	      $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
	      $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
	      methods,
	      key,
	      IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() {
	      return $native.call(this);
	    };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = {};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var create = __webpack_require__(47),
	    descriptor = __webpack_require__(18),
	    setToStringTag = __webpack_require__(25),
	    IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(26)('iterator'), function () {
	  return this;
	});
	
	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $at = __webpack_require__(128)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	
	var $export = __webpack_require__(9),
	    toLength = __webpack_require__(38),
	    context = __webpack_require__(134),
	    ENDS_WITH = 'endsWith',
	    $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH),
	        endPosition = arguments.length > 1 ? arguments[1] : undefined,
	        len = toLength(that.length),
	        end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
	        search = String(searchString);
	    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
	  }
	});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(135),
	    defined = __webpack_require__(36);
	
	module.exports = function (that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(14),
	    cof = __webpack_require__(35),
	    MATCH = __webpack_require__(26)('match');
	module.exports = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var MATCH = __webpack_require__(26)('match');
	module.exports = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch (f) {/* empty */}
	  }return true;
	};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	
	var $export = __webpack_require__(9),
	    context = __webpack_require__(134),
	    INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(136)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */) {
	    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(92)
	});

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	
	var $export = __webpack_require__(9),
	    toLength = __webpack_require__(38),
	    context = __webpack_require__(134),
	    STARTS_WITH = 'startsWith',
	    $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH),
	        index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)),
	        search = String(searchString);
	    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
	  }
	});

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	
	__webpack_require__(141)('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    fails = __webpack_require__(8),
	    defined = __webpack_require__(36),
	    quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function createHTML(string, tag, attribute, value) {
	  var S = String(defined(string)),
	      p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	
	__webpack_require__(141)('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	
	__webpack_require__(141)('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	
	__webpack_require__(141)('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	
	__webpack_require__(141)('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	
	__webpack_require__(141)('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	
	__webpack_require__(141)('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	
	__webpack_require__(141)('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	
	__webpack_require__(141)('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	
	__webpack_require__(141)('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	
	__webpack_require__(141)('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	
	__webpack_require__(141)('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	
	__webpack_require__(141)('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Date', { now: function now() {
	    return new Date().getTime();
	  } });

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toObject = __webpack_require__(59),
	    toPrimitive = __webpack_require__(17);
	
	$export($export.P + $export.F * __webpack_require__(8)(function () {
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
	      return 1;
	    } }) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key) {
	    var O = toObject(this),
	        pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	
	var $export = __webpack_require__(9),
	    fails = __webpack_require__(8),
	    getTime = Date.prototype.getTime;
	
	var lz = function lz(num) {
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function () {
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString() {
	    if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	    var d = this,
	        y = d.getUTCFullYear(),
	        m = d.getUTCMilliseconds(),
	        s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var DateProto = Date.prototype,
	    INVALID_DATE = 'Invalid Date',
	    TO_STRING = 'toString',
	    $toString = DateProto[TO_STRING],
	    getTime = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  __webpack_require__(19)(DateProto, TO_STRING, function toString() {
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var TO_PRIMITIVE = __webpack_require__(26)('toPrimitive'),
	    proto = Date.prototype;
	
	if (!(TO_PRIMITIVE in proto)) __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(159));

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var anObject = __webpack_require__(13),
	    toPrimitive = __webpack_require__(17),
	    NUMBER = 'number';
	
	module.exports = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Array', { isArray: __webpack_require__(46) });

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var ctx = __webpack_require__(21),
	    $export = __webpack_require__(9),
	    toObject = __webpack_require__(59),
	    call = __webpack_require__(162),
	    isArrayIter = __webpack_require__(163),
	    toLength = __webpack_require__(38),
	    createProperty = __webpack_require__(164),
	    getIterFn = __webpack_require__(165);
	
	$export($export.S + $export.F * !__webpack_require__(166)(function (iter) {
	  Array.from(iter);
	}), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /*, mapfn = undefined, thisArg = undefined*/) {
	    var O = toObject(arrayLike),
	        C = typeof this == 'function' ? this : Array,
	        aLen = arguments.length,
	        mapfn = aLen > 1 ? arguments[1] : undefined,
	        mapping = mapfn !== undefined,
	        index = 0,
	        iterFn = getIterFn(O),
	        length,
	        result,
	        step,
	        iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	    // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// check on default Array iterator
	var Iterators = __webpack_require__(130),
	    ITERATOR = __webpack_require__(26)('iterator'),
	    ArrayProto = Array.prototype;
	
	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $defineProperty = __webpack_require__(12),
	    createDesc = __webpack_require__(18);
	
	module.exports = function (object, index, value) {
	  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
	};

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var classof = __webpack_require__(76),
	    ITERATOR = __webpack_require__(26)('iterator'),
	    Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(10).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
	};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var ITERATOR = __webpack_require__(26)('iterator'),
	    SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () {
	    SAFE_CLOSING = true;
	  };
	  Array.from(riter, function () {
	    throw 2;
	  });
	} catch (e) {/* empty */}
	
	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7],
	        iter = arr[ITERATOR]();
	    iter.next = function () {
	      return { done: safe = true };
	    };
	    arr[ITERATOR] = function () {
	      return iter;
	    };
	    exec(arr);
	  } catch (e) {/* empty */}
	  return safe;
	};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    createProperty = __webpack_require__(164);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  function F() {}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of() /* ...args */{
	    var index = 0,
	        aLen = arguments.length,
	        result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) {
	      createProperty(result, index, arguments[index++]);
	    }result.length = aLen;
	    return result;
	  }
	});

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	
	var $export = __webpack_require__(9),
	    toIObject = __webpack_require__(33),
	    arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(34) != Object || !__webpack_require__(169)(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var fails = __webpack_require__(8);
	
	module.exports = function (method, arg) {
	  return !!method && fails(function () {
	    arg ? method.call(null, function () {}, 1) : method.call(null);
	  });
	};

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    html = __webpack_require__(49),
	    cof = __webpack_require__(35),
	    toIndex = __webpack_require__(40),
	    toLength = __webpack_require__(38),
	    arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(8)(function () {
	  if (html) arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length),
	        klass = cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice.call(this, begin, end);
	    var start = toIndex(begin, len),
	        upTo = toIndex(end, len),
	        size = toLength(upTo - start),
	        cloned = Array(size),
	        i = 0;
	    for (; i < size; i++) {
	      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
	    }return cloned;
	  }
	});

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    aFunction = __webpack_require__(22),
	    toObject = __webpack_require__(59),
	    fails = __webpack_require__(8),
	    $sort = [].sort,
	    test = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(169)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $forEach = __webpack_require__(173)(0),
	    STRICT = __webpack_require__(169)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx = __webpack_require__(21),
	    IObject = __webpack_require__(34),
	    toObject = __webpack_require__(59),
	    toLength = __webpack_require__(38),
	    asc = __webpack_require__(174);
	module.exports = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1,
	      IS_FILTER = TYPE == 2,
	      IS_SOME = TYPE == 3,
	      IS_EVERY = TYPE == 4,
	      IS_FIND_INDEX = TYPE == 6,
	      NO_HOLES = TYPE == 5 || IS_FIND_INDEX,
	      create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = toObject($this),
	        self = IObject(O),
	        f = ctx(callbackfn, that, 3),
	        length = toLength(self.length),
	        index = 0,
	        result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined,
	        val,
	        res;
	    for (; length > index; index++) {
	      if (NO_HOLES || index in self) {
	        val = self[index];
	        res = f(val, index, O);
	        if (TYPE) {
	          if (IS_MAP) result[index] = res; // map
	          else if (res) switch (TYPE) {
	              case 3:
	                return true; // some
	              case 5:
	                return val; // find
	              case 6:
	                return index; // findIndex
	              case 2:
	                result.push(val); // filter
	            } else if (IS_EVERY) return false; // every
	        }
	      }
	    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(175);
	
	module.exports = function (original, length) {
	  return new (speciesConstructor(original))(length);
	};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var isObject = __webpack_require__(14),
	    isArray = __webpack_require__(46),
	    SPECIES = __webpack_require__(26)('species');
	
	module.exports = function (original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }return C === undefined ? Array : C;
	};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $map = __webpack_require__(173)(1);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $filter = __webpack_require__(173)(2);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $some = __webpack_require__(173)(3);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $every = __webpack_require__(173)(4);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $reduce = __webpack_require__(181);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var aFunction = __webpack_require__(22),
	    toObject = __webpack_require__(59),
	    IObject = __webpack_require__(34),
	    toLength = __webpack_require__(38);
	
	module.exports = function (that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = toObject(that),
	      self = IObject(O),
	      length = toLength(O.length),
	      index = isRight ? length - 1 : 0,
	      i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (; isRight ? index >= 0 : length > index; index += i) {
	    if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	  }return memo;
	};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $reduce = __webpack_require__(181);
	
	$export($export.P + $export.F * !__webpack_require__(169)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $indexOf = __webpack_require__(37)(false),
	    $native = [].indexOf,
	    NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	    // convert -0 to +0
	    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toIObject = __webpack_require__(33),
	    toInteger = __webpack_require__(39),
	    toLength = __webpack_require__(38),
	    $native = [].lastIndexOf,
	    NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(169)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	    var O = toIObject(this),
	        length = toLength(O.length),
	        index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (; index >= 0; index--) {
	      if (index in O) if (O[index] === searchElement) return index || 0;
	    }return -1;
	  }
	});

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(9);
	
	$export($export.P, 'Array', { copyWithin: __webpack_require__(186) });
	
	__webpack_require__(187)('copyWithin');

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	
	var toObject = __webpack_require__(59),
	    toIndex = __webpack_require__(40),
	    toLength = __webpack_require__(38);
	
	module.exports = [].copyWithin || function copyWithin(target /*= 0*/, start /*= 0, end = @length*/) {
	  var O = toObject(this),
	      len = toLength(O.length),
	      to = toIndex(target, len),
	      from = toIndex(start, len),
	      end = arguments.length > 2 ? arguments[2] : undefined,
	      count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
	      inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }return O;
	};

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(26)('unscopables'),
	    ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
	module.exports = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(9);
	
	$export($export.P, 'Array', { fill: __webpack_require__(189) });
	
	__webpack_require__(187)('fill');

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	
	var toObject = __webpack_require__(59),
	    toIndex = __webpack_require__(40),
	    toLength = __webpack_require__(38);
	module.exports = function fill(value /*, start = 0, end = @length */) {
	  var O = toObject(this),
	      length = toLength(O.length),
	      aLen = arguments.length,
	      index = toIndex(aLen > 1 ? arguments[1] : undefined, length),
	      end = aLen > 2 ? arguments[2] : undefined,
	      endPos = end === undefined ? length : toIndex(end, length);
	  while (endPos > index) {
	    O[index++] = value;
	  }return O;
	};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	
	var $export = __webpack_require__(9),
	    $find = __webpack_require__(173)(5),
	    KEY = 'find',
	    forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () {
	  forced = false;
	});
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn /*, that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	
	var $export = __webpack_require__(9),
	    $find = __webpack_require__(173)(6),
	    KEY = 'findIndex',
	    forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () {
	  forced = false;
	});
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn /*, that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(187)(KEY);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(193)('Array');

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    dP = __webpack_require__(12),
	    DESCRIPTORS = __webpack_require__(7),
	    SPECIES = __webpack_require__(26)('species');
	
	module.exports = function (KEY) {
	  var C = global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function get() {
	      return this;
	    }
	  });
	};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var addToUnscopables = __webpack_require__(187),
	    step = __webpack_require__(195),
	    Iterators = __webpack_require__(130),
	    toIObject = __webpack_require__(33);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(129)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0; // next index
	  this._k = kind; // kind
	  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t,
	      kind = this._k,
	      index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ }),
/* 195 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    inheritIfRequired = __webpack_require__(89),
	    dP = __webpack_require__(12).f,
	    gOPN = __webpack_require__(51).f,
	    isRegExp = __webpack_require__(135),
	    $flags = __webpack_require__(197),
	    $RegExp = global.RegExp,
	    Base = $RegExp,
	    proto = $RegExp.prototype,
	    re1 = /a/g,
	    re2 = /a/g
	// "new" creates a new object, old webkit buggy here
	,
	    CORRECT_NEW = new $RegExp(re1) !== re1;
	
	if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(8)(function () {
	  re2[__webpack_require__(26)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp,
	        piRE = isRegExp(p),
	        fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function proxy(key) {
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function get() {
	        return Base[key];
	      },
	      set: function set(it) {
	        Base[key] = it;
	      }
	    });
	  };
	  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
	    proxy(keys[i++]);
	  }proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(19)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(193)('RegExp');

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	
	var anObject = __webpack_require__(13);
	module.exports = function () {
	  var that = anObject(this),
	      result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(199);
	var anObject = __webpack_require__(13),
	    $flags = __webpack_require__(197),
	    DESCRIPTORS = __webpack_require__(7),
	    TO_STRING = 'toString',
	    $toString = /./[TO_STRING];
	
	var define = function define(fn) {
	  __webpack_require__(19)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if (__webpack_require__(8)(function () {
	  return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
	})) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	  // FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 21.2.5.3 get RegExp.prototype.flags()
	if (__webpack_require__(7) && /./g.flags != 'g') __webpack_require__(12).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(197)
	});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// @@match logic
	__webpack_require__(201)('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {
	    'use strict';
	
	    var O = defined(this),
	        fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var hide = __webpack_require__(11),
	    redefine = __webpack_require__(19),
	    fails = __webpack_require__(8),
	    defined = __webpack_require__(36),
	    wks = __webpack_require__(26);
	
	module.exports = function (KEY, length, exec) {
	  var SYMBOL = wks(KEY),
	      fns = exec(defined, SYMBOL, ''[KEY]),
	      strfn = fns[0],
	      rxfn = fns[1];
	  if (fails(function () {
	    var O = {};
	    O[SYMBOL] = function () {
	      return 7;
	    };
	    return ''[KEY](O) != 7;
	  })) {
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	    ? function (string, arg) {
	      return rxfn.call(string, this, arg);
	    }
	    // 21.2.5.6 RegExp.prototype[@@match](string)
	    // 21.2.5.9 RegExp.prototype[@@search](string)
	    : function (string) {
	      return rxfn.call(string, this);
	    });
	  }
	};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// @@replace logic
	__webpack_require__(201)('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {
	    'use strict';
	
	    var O = defined(this),
	        fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// @@search logic
	__webpack_require__(201)('search', 1, function (defined, SEARCH, $search) {
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp) {
	    'use strict';
	
	    var O = defined(this),
	        fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// @@split logic
	__webpack_require__(201)('split', 2, function (defined, SPLIT, $split) {
	  'use strict';
	
	  var isRegExp = __webpack_require__(135),
	      _split = $split,
	      $push = [].push,
	      $SPLIT = 'split',
	      LENGTH = 'length',
	      LAST_INDEX = 'lastIndex';
	  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function $split(separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) {
	              if (arguments[i] === undefined) match[i] = undefined;
	            }
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	    // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function $split(separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this),
	        fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var LIBRARY = __webpack_require__(29),
	    global = __webpack_require__(5),
	    ctx = __webpack_require__(21),
	    classof = __webpack_require__(76),
	    $export = __webpack_require__(9),
	    isObject = __webpack_require__(14),
	    aFunction = __webpack_require__(22),
	    anInstance = __webpack_require__(206),
	    forOf = __webpack_require__(207),
	    speciesConstructor = __webpack_require__(208),
	    task = __webpack_require__(209).set,
	    microtask = __webpack_require__(210)(),
	    PROMISE = 'Promise',
	    TypeError = global.TypeError,
	    process = global.process,
	    $Promise = global[PROMISE],
	    process = global.process,
	    isNode = classof(process) == 'process',
	    empty = function empty() {/* empty */},
	    Internal,
	    GenericPromiseCapability,
	    Wrapper;
	
	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1),
	        FakePromise = (promise.constructor = {})[__webpack_require__(26)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch (e) {/* empty */}
	}();
	
	// helpers
	var sameConstructor = function sameConstructor(a, b) {
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function isThenable(it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function newPromiseCapability(C) {
	  return sameConstructor($Promise, C) ? new PromiseCapability(C) : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function GenericPromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	};
	var perform = function perform(exec) {
	  try {
	    exec();
	  } catch (e) {
	    return { error: e };
	  }
	};
	var notify = function notify(promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v,
	        ok = promise._s == 1,
	        i = 0;
	    var run = function run(reaction) {
	      var handler = ok ? reaction.ok : reaction.fail,
	          resolve = reaction.resolve,
	          reject = reaction.reject,
	          domain = reaction.domain,
	          result,
	          then;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) domain.exit();
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        reject(e);
	      }
	    };
	    while (chain.length > i) {
	      run(chain[i++]);
	    } // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function onUnhandled(promise) {
	  task.call(global, function () {
	    var value = promise._v,
	        abrupt,
	        handler,
	        console;
	    if (isUnhandled(promise)) {
	      abrupt = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    }promise._a = undefined;
	    if (abrupt) throw abrupt.error;
	  });
	};
	var isUnhandled = function isUnhandled(promise) {
	  if (promise._h == 1) return false;
	  var chain = promise._a || promise._c,
	      i = 0,
	      reaction;
	  while (chain.length > i) {
	    reaction = chain[i++];
	    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
	  }return true;
	};
	var onHandleUnhandled = function onHandleUnhandled(promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function $reject(value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function $resolve(value) {
	  var promise = this,
	      then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};
	
	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor) {
	    this._c = []; // <- awaiting reactions
	    this._a = undefined; // <- checked in isUnhandled reactions
	    this._s = 0; // <- state
	    this._d = false; // <- done
	    this._v = undefined; // <- value
	    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false; // <- notify
	  };
	  Internal.prototype = __webpack_require__(211)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function _catch(onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function PromiseCapability() {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(25)($Promise, PROMISE);
	__webpack_require__(193)(PROMISE);
	Wrapper = __webpack_require__(10)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this),
	        $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
	    var capability = newPromiseCapability(this),
	        $$resolve = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(166)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this,
	        capability = newPromiseCapability(C),
	        resolve = capability.resolve,
	        reject = capability.reject;
	    var abrupt = perform(function () {
	      var values = [],
	          index = 0,
	          remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++,
	            alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (abrupt) reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this,
	        capability = newPromiseCapability(C),
	        reject = capability.reject;
	    var abrupt = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (abrupt) reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
	    throw TypeError(name + ': incorrect invocation!');
	  }return it;
	};

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var ctx = __webpack_require__(21),
	    call = __webpack_require__(162),
	    isArrayIter = __webpack_require__(163),
	    anObject = __webpack_require__(13),
	    toLength = __webpack_require__(38),
	    getIterFn = __webpack_require__(165),
	    BREAK = {},
	    RETURN = {};
	var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () {
	    return iterable;
	  } : getIterFn(iterable),
	      f = ctx(fn, that, entries ? 2 : 1),
	      index = 0,
	      length,
	      step,
	      iterator,
	      result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	_exports.BREAK = BREAK;
	_exports.RETURN = RETURN;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(13),
	    aFunction = __webpack_require__(22),
	    SPECIES = __webpack_require__(26)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor,
	      S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var ctx = __webpack_require__(21),
	    invoke = __webpack_require__(79),
	    html = __webpack_require__(49),
	    cel = __webpack_require__(16),
	    global = __webpack_require__(5),
	    process = global.process,
	    setTask = global.setImmediate,
	    clearTask = global.clearImmediate,
	    MessageChannel = global.MessageChannel,
	    counter = 0,
	    queue = {},
	    ONREADYSTATECHANGE = 'onreadystatechange',
	    defer,
	    channel,
	    port;
	var run = function run() {
	  var id = +this;
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function listener(event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [],
	        i = 1;
	    while (arguments.length > i) {
	      args.push(arguments[i++]);
	    }queue[++counter] = function () {
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(35)(process) == 'process') {
	    defer = function defer(id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	    // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	    // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function defer(id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	    // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function defer(id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	    // Rest old browsers
	  } else {
	    defer = function defer(id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    macrotask = __webpack_require__(209).set,
	    Observer = global.MutationObserver || global.WebKitMutationObserver,
	    process = global.process,
	    Promise = global.Promise,
	    isNode = __webpack_require__(35)(process) == 'process';
	
	module.exports = function () {
	  var head, last, notify;
	
	  var flush = function flush() {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();else last = undefined;
	        throw e;
	      }
	    }last = undefined;
	    if (parent) parent.enter();
	  };
	
	  // Node.js
	  if (isNode) {
	    notify = function notify() {
	      process.nextTick(flush);
	    };
	    // browsers with MutationObserver
	  } else if (Observer) {
	    var toggle = true,
	        node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function notify() {
	      node.data = toggle = !toggle;
	    };
	    // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    var promise = Promise.resolve();
	    notify = function notify() {
	      promise.then(flush);
	    };
	    // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout
	  } else {
	    notify = function notify() {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    }last = task;
	  };
	};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var redefine = __webpack_require__(19);
	module.exports = function (target, src, safe) {
	  for (var key in src) {
	    redefine(target, key, src[key], safe);
	  }return target;
	};

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var strong = __webpack_require__(213);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(214)('Map', function (get) {
	  return function Map() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var dP = __webpack_require__(12).f,
	    create = __webpack_require__(47),
	    redefineAll = __webpack_require__(211),
	    ctx = __webpack_require__(21),
	    anInstance = __webpack_require__(206),
	    defined = __webpack_require__(36),
	    forOf = __webpack_require__(207),
	    $iterDefine = __webpack_require__(129),
	    step = __webpack_require__(195),
	    setSpecies = __webpack_require__(193),
	    DESCRIPTORS = __webpack_require__(7),
	    fastKey = __webpack_require__(23).fastKey,
	    SIZE = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function getEntry(that, key) {
	  // fast case
	  var index = fastKey(key),
	      entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined; // first entry
	      that._l = undefined; // last entry
	      that[SIZE] = 0; // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function _delete(key) {
	        var that = this,
	            entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n,
	              prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        }return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */) {
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
	            entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) {
	            entry = entry.p;
	          }
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });
	    if (DESCRIPTORS) dP(C.prototype, 'size', {
	      get: function get() {
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var entry = getEntry(that, key),
	        prev,
	        index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	      // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key, // <- key
	        v: value, // <- value
	        p: prev = that._l, // <- previous entry
	        n: undefined, // <- next entry
	        r: false // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    }return that;
	  },
	  getEntry: getEntry,
	  setStrong: function setStrong(C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = iterated; // target
	      this._k = kind; // kind
	      this._l = undefined; // previous
	    }, function () {
	      var that = this,
	          kind = that._k,
	          entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) {
	        entry = entry.p;
	      } // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    $export = __webpack_require__(9),
	    redefine = __webpack_require__(19),
	    redefineAll = __webpack_require__(211),
	    meta = __webpack_require__(23),
	    forOf = __webpack_require__(207),
	    anInstance = __webpack_require__(206),
	    isObject = __webpack_require__(14),
	    fails = __webpack_require__(8),
	    $iterDetect = __webpack_require__(166),
	    setToStringTag = __webpack_require__(25),
	    inheritIfRequired = __webpack_require__(89);
	
	module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = global[NAME],
	      C = Base,
	      ADDER = IS_MAP ? 'set' : 'add',
	      proto = C && C.prototype,
	      O = {};
	  var fixMethod = function fixMethod(KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY, KEY == 'delete' ? function (a) {
	      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'has' ? function has(a) {
	      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'get' ? function get(a) {
	      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	    } : KEY == 'add' ? function add(a) {
	      fn.call(this, a === 0 ? 0 : a);return this;
	    } : function set(a, b) {
	      fn.call(this, a === 0 ? 0 : a, b);return this;
	    });
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance = new C()
	    // early implementations not supports chaining
	    ,
	        HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    ,
	        THROWS_ON_PRIMITIVES = fails(function () {
	      instance.has(1);
	    })
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    ,
	        ACCEPT_ITERABLES = $iterDetect(function (iter) {
	      new C(iter);
	    }) // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    ,
	        BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C(),
	          index = 5;
	      while (index--) {
	        $instance[ADDER](index, index);
	      }return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var strong = __webpack_require__(213);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(214)('Set', function (get) {
	  return function Set() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var each = __webpack_require__(173)(0),
	    redefine = __webpack_require__(19),
	    meta = __webpack_require__(23),
	    assign = __webpack_require__(70),
	    weak = __webpack_require__(217),
	    isObject = __webpack_require__(14),
	    getWeak = meta.getWeak,
	    isExtensible = Object.isExtensible,
	    uncaughtFrozenStore = weak.ufstore,
	    tmp = {},
	    InternalMap;
	
	var wrapper = function wrapper(get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(214)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype,
	        method = proto[key];
	    redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	        // store all the rest on native weakmap
	      }return method.call(this, a, b);
	    });
	  });
	}

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var redefineAll = __webpack_require__(211),
	    getWeak = __webpack_require__(23).getWeak,
	    anObject = __webpack_require__(13),
	    isObject = __webpack_require__(14),
	    anInstance = __webpack_require__(206),
	    forOf = __webpack_require__(207),
	    createArrayMethod = __webpack_require__(173),
	    $has = __webpack_require__(6),
	    arrayFind = createArrayMethod(5),
	    arrayFindIndex = createArrayMethod(6),
	    id = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function UncaughtFrozenStore() {
	  this.a = [];
	};
	var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function get(key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function has(key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function set(key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;else this.a.push([key, value]);
	  },
	  'delete': function _delete(key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._i = id++; // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function _delete(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function def(that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var weak = __webpack_require__(217);
	
	// 23.4 WeakSet Objects
	__webpack_require__(214)('WeakSet', function (get) {
	  return function WeakSet() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $typed = __webpack_require__(220),
	    buffer = __webpack_require__(221),
	    anObject = __webpack_require__(13),
	    toIndex = __webpack_require__(40),
	    toLength = __webpack_require__(38),
	    isObject = __webpack_require__(14),
	    ArrayBuffer = __webpack_require__(5).ArrayBuffer,
	    speciesConstructor = __webpack_require__(208),
	    $ArrayBuffer = buffer.ArrayBuffer,
	    $DataView = buffer.DataView,
	    $isView = $typed.ABV && ArrayBuffer.isView,
	    $slice = $ArrayBuffer.prototype.slice,
	    VIEW = $typed.VIEW,
	    ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(8)(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength,
	        first = toIndex(start, len),
	        final = toIndex(end === undefined ? len : end, len),
	        result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first)),
	        viewS = new $DataView(this),
	        viewT = new $DataView(result),
	        index = 0;
	    while (first < final) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    }return result;
	  }
	});
	
	__webpack_require__(193)(ARRAY_BUFFER);

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    hide = __webpack_require__(11),
	    uid = __webpack_require__(20),
	    TYPED = uid('typed_array'),
	    VIEW = uid('view'),
	    ABV = !!(global.ArrayBuffer && global.DataView),
	    CONSTR = ABV,
	    i = 0,
	    l = 9,
	    Typed;
	
	var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');
	
	while (i < l) {
	  if (Typed = global[TypedArrayConstructors[i++]]) {
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var global = __webpack_require__(5),
	    DESCRIPTORS = __webpack_require__(7),
	    LIBRARY = __webpack_require__(29),
	    $typed = __webpack_require__(220),
	    hide = __webpack_require__(11),
	    redefineAll = __webpack_require__(211),
	    fails = __webpack_require__(8),
	    anInstance = __webpack_require__(206),
	    toInteger = __webpack_require__(39),
	    toLength = __webpack_require__(38),
	    gOPN = __webpack_require__(51).f,
	    dP = __webpack_require__(12).f,
	    arrayFill = __webpack_require__(189),
	    setToStringTag = __webpack_require__(25),
	    ARRAY_BUFFER = 'ArrayBuffer',
	    DATA_VIEW = 'DataView',
	    PROTOTYPE = 'prototype',
	    WRONG_LENGTH = 'Wrong length!',
	    WRONG_INDEX = 'Wrong index!',
	    $ArrayBuffer = global[ARRAY_BUFFER],
	    $DataView = global[DATA_VIEW],
	    Math = global.Math,
	    RangeError = global.RangeError,
	    Infinity = global.Infinity,
	    BaseBuffer = $ArrayBuffer,
	    abs = Math.abs,
	    pow = Math.pow,
	    floor = Math.floor,
	    log = Math.log,
	    LN2 = Math.LN2,
	    BUFFER = 'buffer',
	    BYTE_LENGTH = 'byteLength',
	    BYTE_OFFSET = 'byteOffset',
	    $BUFFER = DESCRIPTORS ? '_b' : BUFFER,
	    $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH,
	    $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function packIEEE754(value, mLen, nBytes) {
	  var buffer = Array(nBytes),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
	      i = 0,
	      s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0,
	      e,
	      m,
	      c;
	  value = abs(value);
	  if (value != value || value === Infinity) {
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = eLen - 7,
	      i = nBytes - 1,
	      s = buffer[i--],
	      e = s & 127,
	      m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  }return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function packI8(it) {
	  return [it & 0xff];
	};
	var packI16 = function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function packF64(it) {
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function packF32(it) {
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function get() {
	      return this[internal];
	    } });
	};
	
	var get = function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index,
	      intIndex = toInteger(numIndex);
	  if (numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b,
	      start = intIndex + view[$OFFSET],
	      pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index,
	      intIndex = toInteger(numIndex);
	  if (numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b,
	      start = intIndex + view[$OFFSET],
	      pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) {
	    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	  }
	};
	
	var validateArrayBufferArguments = function validateArrayBufferArguments(that, length) {
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length,
	      byteLength = toLength(numberLength);
	  if (numberLength != byteLength) throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if (!$typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH],
	        offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if (DESCRIPTORS) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	  }) || !fails(function () {
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2)),
	      $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9);
	$export($export.G + $export.W + $export.F * !__webpack_require__(220).ABV, {
	  DataView: __webpack_require__(221).DataView
	});

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	if (__webpack_require__(7)) {
	  var LIBRARY = __webpack_require__(29),
	      global = __webpack_require__(5),
	      fails = __webpack_require__(8),
	      $export = __webpack_require__(9),
	      $typed = __webpack_require__(220),
	      $buffer = __webpack_require__(221),
	      ctx = __webpack_require__(21),
	      anInstance = __webpack_require__(206),
	      propertyDesc = __webpack_require__(18),
	      hide = __webpack_require__(11),
	      redefineAll = __webpack_require__(211),
	      toInteger = __webpack_require__(39),
	      toLength = __webpack_require__(38),
	      toIndex = __webpack_require__(40),
	      toPrimitive = __webpack_require__(17),
	      has = __webpack_require__(6),
	      same = __webpack_require__(72),
	      classof = __webpack_require__(76),
	      isObject = __webpack_require__(14),
	      toObject = __webpack_require__(59),
	      isArrayIter = __webpack_require__(163),
	      create = __webpack_require__(47),
	      getPrototypeOf = __webpack_require__(60),
	      gOPN = __webpack_require__(51).f,
	      getIterFn = __webpack_require__(165),
	      uid = __webpack_require__(20),
	      wks = __webpack_require__(26),
	      createArrayMethod = __webpack_require__(173),
	      createArrayIncludes = __webpack_require__(37),
	      speciesConstructor = __webpack_require__(208),
	      ArrayIterators = __webpack_require__(194),
	      Iterators = __webpack_require__(130),
	      $iterDetect = __webpack_require__(166),
	      setSpecies = __webpack_require__(193),
	      arrayFill = __webpack_require__(189),
	      arrayCopyWithin = __webpack_require__(186),
	      $DP = __webpack_require__(12),
	      $GOPD = __webpack_require__(52),
	      dP = $DP.f,
	      gOPD = $GOPD.f,
	      RangeError = global.RangeError,
	      TypeError = global.TypeError,
	      Uint8Array = global.Uint8Array,
	      ARRAY_BUFFER = 'ArrayBuffer',
	      SHARED_BUFFER = 'Shared' + ARRAY_BUFFER,
	      BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT',
	      PROTOTYPE = 'prototype',
	      ArrayProto = Array[PROTOTYPE],
	      $ArrayBuffer = $buffer.ArrayBuffer,
	      $DataView = $buffer.DataView,
	      arrayForEach = createArrayMethod(0),
	      arrayFilter = createArrayMethod(2),
	      arraySome = createArrayMethod(3),
	      arrayEvery = createArrayMethod(4),
	      arrayFind = createArrayMethod(5),
	      arrayFindIndex = createArrayMethod(6),
	      arrayIncludes = createArrayIncludes(true),
	      arrayIndexOf = createArrayIncludes(false),
	      arrayValues = ArrayIterators.values,
	      arrayKeys = ArrayIterators.keys,
	      arrayEntries = ArrayIterators.entries,
	      arrayLastIndexOf = ArrayProto.lastIndexOf,
	      arrayReduce = ArrayProto.reduce,
	      arrayReduceRight = ArrayProto.reduceRight,
	      arrayJoin = ArrayProto.join,
	      arraySort = ArrayProto.sort,
	      arraySlice = ArrayProto.slice,
	      arrayToString = ArrayProto.toString,
	      arrayToLocaleString = ArrayProto.toLocaleString,
	      ITERATOR = wks('iterator'),
	      TAG = wks('toStringTag'),
	      TYPED_CONSTRUCTOR = uid('typed_constructor'),
	      DEF_CONSTRUCTOR = uid('def_constructor'),
	      ALL_CONSTRUCTORS = $typed.CONSTR,
	      TYPED_ARRAY = $typed.TYPED,
	      VIEW = $typed.VIEW,
	      WRONG_LENGTH = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function () {
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function strictToLength(it, SAME) {
	    if (it === undefined) throw TypeError(WRONG_LENGTH);
	    var number = +it,
	        length = toLength(it);
	    if (SAME && !same(number, length)) throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function toOffset(it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function validate(it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function allocate(C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    }return new C(length);
	  };
	
	  var speciesFromList = function speciesFromList(O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function fromList(C, list) {
	    var index = 0,
	        length = list.length,
	        result = allocate(C, length);
	    while (length > index) {
	      result[index] = list[index++];
	    }return result;
	  };
	
	  var addGetter = function addGetter(it, key, internal) {
	    dP(it, key, { get: function get() {
	        return this._d[internal];
	      } });
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */) {
	    var O = toObject(source),
	        aLen = arguments.length,
	        mapfn = aLen > 1 ? arguments[1] : undefined,
	        mapping = mapfn !== undefined,
	        iterFn = getIterFn(O),
	        i,
	        length,
	        values,
	        result,
	        step,
	        iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      }O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of() /*...items*/{
	    var index = 0,
	        length = arguments.length,
	        result = allocate(this, length);
	    while (length > index) {
	      result[index] = arguments[index++];
	    }return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
	    arrayToLocaleString.call(new Uint8Array(1));
	  });
	
	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */) {
	      // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) {
	      // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */) {
	      // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */) {
	      // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */) {
	      // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this,
	          length = validate(that).length,
	          middle = Math.floor(length / 2),
	          index = 0,
	          value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      }return that;
	    },
	    some: function some(callbackfn /*, thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this),
	          length = O.length,
	          $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toIndex(end, length)) - $begin));
	    }
	  };
	
	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1),
	        length = this.length,
	        src = toObject(arrayLike),
	        len = toLength(src.length),
	        index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) {
	      this[offset + index] = src[index++];
	    }
	  };
	
	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function isTAIndex(target, key) {
	    return isObject(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
	    // TODO: add validation descriptor w/o calling accessors
	    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });
	
	  if (fails(function () {
	    arrayToString.call({});
	  })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function constructor() {/* noop */},
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function get() {
	      return this[TYPED_ARRAY];
	    }
	  });
	
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array',
	        ISNT_UINT8 = NAME != 'Uint8Array',
	        GETTER = 'get' + KEY,
	        SETTER = 'set' + KEY,
	        TypedArray = global[NAME],
	        Base = TypedArray || {},
	        TAC = TypedArray && getPrototypeOf(TypedArray),
	        FORCED = !TypedArray || !$typed.ABV,
	        O = {},
	        TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function getter(that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function setter(that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function addElement(that, index) {
	      dP(that, index, {
	        get: function get() {
	          return getter(this, index);
	        },
	        set: function set(value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0,
	            offset = 0,
	            buffer,
	            byteLength,
	            length,
	            klass;
	        if (!isObject(data)) {
	          length = strictToLength(data, true);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) {
	          addElement(that, index++);
	        }
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!$iterDetect(function (iter) {
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) return new Base(strictToLength(data, ISNT_UINT8));
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR],
	        CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined),
	        $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function get() {
	          return NAME;
	        }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, { toString: arrayToString });
	
	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });
	
	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () {/* empty */};

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(224)('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export = __webpack_require__(9),
	    aFunction = __webpack_require__(22),
	    anObject = __webpack_require__(13),
	    rApply = (__webpack_require__(5).Reflect || {}).apply,
	    fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(8)(function () {
	  rApply(function () {});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target),
	        L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export = __webpack_require__(9),
	    create = __webpack_require__(47),
	    aFunction = __webpack_require__(22),
	    anObject = __webpack_require__(13),
	    isObject = __webpack_require__(14),
	    fails = __webpack_require__(8),
	    bind = __webpack_require__(78),
	    rConstruct = (__webpack_require__(5).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() {}
	  return !(rConstruct(function () {}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  rConstruct(function () {});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0:
	          return new Target();
	        case 1:
	          return new Target(args[0]);
	        case 2:
	          return new Target(args[0], args[1]);
	        case 3:
	          return new Target(args[0], args[1], args[2]);
	        case 4:
	          return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype,
	        instance = create(isObject(proto) ? proto : Object.prototype),
	        result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP = __webpack_require__(12),
	    $export = __webpack_require__(9),
	    anObject = __webpack_require__(13),
	    toPrimitive = __webpack_require__(17);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export = __webpack_require__(9),
	    gOPD = __webpack_require__(52).f,
	    anObject = __webpack_require__(13);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	
	var $export = __webpack_require__(9),
	    anObject = __webpack_require__(13);
	var Enumerate = function Enumerate(iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0; // next index
	  var keys = this._k = [] // keys
	  ,
	      key;
	  for (key in iterated) {
	    keys.push(key);
	  }
	};
	__webpack_require__(131)(Enumerate, 'Object', function () {
	  var that = this,
	      keys = that._k,
	      key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD = __webpack_require__(52),
	    getPrototypeOf = __webpack_require__(60),
	    has = __webpack_require__(6),
	    $export = __webpack_require__(9),
	    isObject = __webpack_require__(14),
	    anObject = __webpack_require__(13);
	
	function get(target, propertyKey /*, receiver*/) {
	  var receiver = arguments.length < 3 ? target : arguments[2],
	      desc,
	      proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
	  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', { get: get });

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD = __webpack_require__(52),
	    $export = __webpack_require__(9),
	    anObject = __webpack_require__(13);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export = __webpack_require__(9),
	    getProto = __webpack_require__(60),
	    anObject = __webpack_require__(13);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return getProto(anObject(target));
	  }
	});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.10 Reflect.isExtensible(target)
	var $export = __webpack_require__(9),
	    anObject = __webpack_require__(13),
	    $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Reflect', { ownKeys: __webpack_require__(244) });

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// all object keys, includes non-enumerable and symbols
	var gOPN = __webpack_require__(51),
	    gOPS = __webpack_require__(44),
	    anObject = __webpack_require__(13),
	    Reflect = __webpack_require__(5).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it)),
	      getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.12 Reflect.preventExtensions(target)
	var $export = __webpack_require__(9),
	    anObject = __webpack_require__(13),
	    $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP = __webpack_require__(12),
	    gOPD = __webpack_require__(52),
	    getPrototypeOf = __webpack_require__(60),
	    has = __webpack_require__(6),
	    $export = __webpack_require__(9),
	    createDesc = __webpack_require__(18),
	    anObject = __webpack_require__(13),
	    isObject = __webpack_require__(14);
	
	function set(target, propertyKey, V /*, receiver*/) {
	  var receiver = arguments.length < 4 ? target : arguments[3],
	      ownDesc = gOPD.f(anObject(target), propertyKey),
	      existingDescriptor,
	      proto;
	  if (!ownDesc) {
	    if (isObject(proto = getPrototypeOf(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', { set: set });

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export = __webpack_require__(9),
	    setProto = __webpack_require__(74);
	
	if (setProto) $export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	
	var $export = __webpack_require__(9),
	    $includes = __webpack_require__(37)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(187)('includes');

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	
	var $export = __webpack_require__(9),
	    $at = __webpack_require__(128)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos) {
	    return $at(this, pos);
	  }
	});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	
	var $export = __webpack_require__(9),
	    $pad = __webpack_require__(251);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(38),
	    repeat = __webpack_require__(92),
	    defined = __webpack_require__(36);
	
	module.exports = function (that, maxLength, fillString, left) {
	  var S = String(defined(that)),
	      stringLength = S.length,
	      fillStr = fillString === undefined ? ' ' : String(fillString),
	      intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength,
	      stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	
	var $export = __webpack_require__(9),
	    $pad = __webpack_require__(251);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	
	__webpack_require__(84)('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	
	__webpack_require__(84)('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	
	var $export = __webpack_require__(9),
	    defined = __webpack_require__(36),
	    toLength = __webpack_require__(38),
	    isRegExp = __webpack_require__(135),
	    getFlags = __webpack_require__(197),
	    RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(131)($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this),
	        flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp),
	        rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(28)('asyncIterator');

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(28)('observable');

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export = __webpack_require__(9),
	    ownKeys = __webpack_require__(244),
	    toIObject = __webpack_require__(33),
	    gOPD = __webpack_require__(52),
	    createProperty = __webpack_require__(164);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object),
	        getDesc = gOPD.f,
	        keys = ownKeys(O),
	        result = {},
	        i = 0,
	        key;
	    while (keys.length > i) {
	      createProperty(result, key = keys[i++], getDesc(O, key));
	    }return result;
	  }
	});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(9),
	    $values = __webpack_require__(260)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var getKeys = __webpack_require__(31),
	    toIObject = __webpack_require__(33),
	    isEnum = __webpack_require__(45).f;
	module.exports = function (isEntries) {
	  return function (it) {
	    var O = toIObject(it),
	        keys = getKeys(O),
	        length = keys.length,
	        i = 0,
	        result = [],
	        key;
	    while (length > i) {
	      if (isEnum.call(O, key = keys[i++])) {
	        result.push(isEntries ? [key, O[key]] : O[key]);
	      }
	    }return result;
	  };
	};

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(9),
	    $entries = __webpack_require__(260)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toObject = __webpack_require__(59),
	    aFunction = __webpack_require__(22),
	    $defineProperty = __webpack_require__(12);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(29) || !__webpack_require__(8)(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function () {/* empty */});
	  delete __webpack_require__(5)[K];
	});

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toObject = __webpack_require__(59),
	    aFunction = __webpack_require__(22),
	    $defineProperty = __webpack_require__(12);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toObject = __webpack_require__(59),
	    toPrimitive = __webpack_require__(17),
	    getPrototypeOf = __webpack_require__(60),
	    getOwnPropertyDescriptor = __webpack_require__(52).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = toObject(this),
	        K = toPrimitive(P, true),
	        D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = getPrototypeOf(O));
	  }
	});

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    toObject = __webpack_require__(59),
	    toPrimitive = __webpack_require__(17),
	    getPrototypeOf = __webpack_require__(60),
	    getOwnPropertyDescriptor = __webpack_require__(52).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(263), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = toObject(this),
	        K = toPrimitive(P, true),
	        D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
	    } while (O = getPrototypeOf(O));
	  }
	});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(9);
	
	$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(268)('Map') });

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(76),
	    from = __webpack_require__(269);
	module.exports = function (NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var forOf = __webpack_require__(207);
	
	module.exports = function (iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(9);
	
	$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(268)('Set') });

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(9);
	
	$export($export.S, 'System', { global: __webpack_require__(5) });

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(9),
	    cof = __webpack_require__(35);
	
	$export($export.S, 'Error', {
	  isError: function isError(it) {
	    return cof(it) === 'Error';
	  }
	});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0,
	        $x1 = x1 >>> 0,
	        $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0,
	        $x1 = x1 >>> 0,
	        $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff,
	        $u = +u,
	        $v = +v,
	        u0 = $u & UINT16,
	        v0 = $v & UINT16,
	        u1 = $u >> 16,
	        v1 = $v >> 16,
	        t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff,
	        $u = +u,
	        $v = +v,
	        u0 = $u & UINT16,
	        v0 = $v & UINT16,
	        u1 = $u >>> 16,
	        v1 = $v >>> 16,
	        t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    toMetaKey = metadata.key,
	    ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	  } });

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var Map = __webpack_require__(212),
	    $export = __webpack_require__(9),
	    shared = __webpack_require__(24)('metadata'),
	    store = shared.store || (shared.store = new (__webpack_require__(216))());
	
	var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
	  var targetMetadata = store.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store.set(target, targetMetadata = new Map());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map());
	  }return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false),
	      keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) {
	    keys.push(key);
	  });
	  return keys;
	};
	var toMetaKey = function toMetaKey(it) {
	  return it === undefined || (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : String(it);
	};
	var exp = function exp(O) {
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    toMetaKey = metadata.key,
	    getOrCreateMetadataMap = metadata.map,
	    store = metadata.store;
	
	metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]),
	        metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	    if (metadataMap.size) return true;
	    var targetMetadata = store.get(target);
	    targetMetadata['delete'](targetKey);
	    return !!targetMetadata.size || store['delete'](target);
	  } });

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    getPrototypeOf = __webpack_require__(60),
	    ordinaryHasOwnMetadata = metadata.has,
	    ordinaryGetOwnMetadata = metadata.get,
	    toMetaKey = metadata.key;
	
	var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({ getMetadata: function getMetadata(metadataKey, target /*, targetKey */) {
	    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	  } });

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Set = __webpack_require__(215),
	    from = __webpack_require__(269),
	    metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    getPrototypeOf = __webpack_require__(60),
	    ordinaryOwnMetadataKeys = metadata.keys,
	    toMetaKey = metadata.key;
	
	var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
	  var oKeys = ordinaryOwnMetadataKeys(O, P),
	      parent = getPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({ getMetadataKeys: function getMetadataKeys(target /*, targetKey */) {
	    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	  } });

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    ordinaryGetOwnMetadata = metadata.get,
	    toMetaKey = metadata.key;
	
	metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */) {
	    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	  } });

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    ordinaryOwnMetadataKeys = metadata.keys,
	    toMetaKey = metadata.key;
	
	metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */) {
	    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	  } });

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    getPrototypeOf = __webpack_require__(60),
	    ordinaryHasOwnMetadata = metadata.has,
	    toMetaKey = metadata.key;
	
	var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */) {
	    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	  } });

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    ordinaryHasOwnMetadata = metadata.has,
	    toMetaKey = metadata.key;
	
	metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */) {
	    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	  } });

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var metadata = __webpack_require__(278),
	    anObject = __webpack_require__(13),
	    aFunction = __webpack_require__(22),
	    toMetaKey = metadata.key,
	    ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	    return function decorator(target, targetKey) {
	      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
	    };
	  } });

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export = __webpack_require__(9),
	    microtask = __webpack_require__(210)(),
	    process = __webpack_require__(5).process,
	    isNode = __webpack_require__(35)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn) {
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	
	var $export = __webpack_require__(9),
	    global = __webpack_require__(5),
	    core = __webpack_require__(10),
	    microtask = __webpack_require__(210)(),
	    OBSERVABLE = __webpack_require__(26)('observable'),
	    aFunction = __webpack_require__(22),
	    anObject = __webpack_require__(13),
	    anInstance = __webpack_require__(206),
	    redefineAll = __webpack_require__(211),
	    hide = __webpack_require__(11),
	    forOf = __webpack_require__(207),
	    RETURN = forOf.RETURN;
	
	var getMethod = function getMethod(fn) {
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function cleanupSubscription(subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function subscriptionClosed(subscription) {
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function closeSubscription(subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function Subscription(observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer),
	        subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
	        subscription.unsubscribe();
	      };else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  }if (subscriptionClosed(this)) cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() {
	    closeSubscription(this);
	  }
	});
	
	var SubscriptionObserver = function SubscriptionObserver(subscription) {
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    }cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber) {
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (core.Promise || global.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function next(value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          }observer.complete();
	        }
	      });
	      return function () {
	        done = true;
	      };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = Array(l); i < l;) {
	      items[i] = arguments[i++];
	    }return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          for (var i = 0; i < items.length; ++i) {
	            observer.next(items[i]);
	            if (done) return;
	          }observer.complete();
	        }
	      });
	      return function () {
	        done = true;
	      };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function () {
	  return this;
	});
	
	$export($export.G, { Observable: $Observable });
	
	__webpack_require__(193)('Observable');

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// ie9- setTimeout & setInterval additional parameters fix
	var global = __webpack_require__(5),
	    $export = __webpack_require__(9),
	    invoke = __webpack_require__(79),
	    partial = __webpack_require__(290),
	    navigator = global.navigator,
	    MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function wrap(set) {
	  return MSIE ? function (fn, time /*, ...args */) {
	    return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout: wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var path = __webpack_require__(291),
	    invoke = __webpack_require__(79),
	    aFunction = __webpack_require__(22);
	module.exports = function () /* ...pargs */{
	  var fn = aFunction(this),
	      length = arguments.length,
	      pargs = Array(length),
	      i = 0,
	      _ = path._,
	      holder = false;
	  while (length > i) {
	    if ((pargs[i] = arguments[i++]) === _) holder = true;
	  }return function () /* ...args */{
	    var that = this,
	        aLen = arguments.length,
	        j = 0,
	        k = 0,
	        args;
	    if (!holder && !aLen) return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if (holder) for (; length > j; j++) {
	      if (args[j] === _) args[j] = arguments[k++];
	    }while (aLen > k) {
	      args.push(arguments[k++]);
	    }return invoke(fn, args, that);
	  };
	};

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(5);

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $export = __webpack_require__(9),
	    $task = __webpack_require__(209);
	$export($export.G + $export.B, {
	  setImmediate: $task.set,
	  clearImmediate: $task.clear
	});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var $iterators = __webpack_require__(194),
	    redefine = __webpack_require__(19),
	    global = __webpack_require__(5),
	    hide = __webpack_require__(11),
	    Iterators = __webpack_require__(130),
	    wks = __webpack_require__(26),
	    ITERATOR = wks('iterator'),
	    TO_STRING_TAG = wks('toStringTag'),
	    ArrayValues = Iterators.Array;
	
	for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
	  var NAME = collections[i],
	      Collection = global[NAME],
	      proto = Collection && Collection.prototype,
	      key;
	  if (proto) {
	    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for (key in $iterators) {
	      if (!proto[key]) redefine(proto, key, $iterators[key], true);
	    }
	  }
	}

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!function (global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = ( false ? "undefined" : _typeof(module)) === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      prototype[method] = function (arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction ||
	    // For the native GeneratorFunction constructor, the best we can
	    // do is to check its .name property.
	    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };
	
	  runtime.mark = function (genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function (arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function (value) {
	            invoke("next", value, resolve, reject);
	          }, function (err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function (unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (_typeof(global.process) === "object" && global.process.domain) {
	      invoke = global.process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function (resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	      // If enqueue has been called before, then we want to wait until
	      // all previous Promises have been resolved before calling invoke,
	      // so that results are always delivered in the correct order. If
	      // enqueue has not been called before, then it is important to
	      // call invoke immediately, without waiting on a callback to fire,
	      // so that the async generator function has the opportunity to do
	      // any necessary setup in a predictable way. This predictability
	      // is why the Promise constructor synchronously invokes its
	      // executor callback, and why async functions synchronously
	      // execute code before the first await. Since we implement simple
	      // async functions in terms of async generators, it is especially
	      // important to get this right, even though it requires care.
	      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
	      // Avoid propagating failures to Promises returned by later
	      // invocations of the iterator.
	      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
	
	    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	    : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      context.method = method;
	      context.arg = arg;
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	
	          context.dispatchException(context.arg);
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;
	
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	
	          return {
	            value: record.arg,
	            done: context.done
	          };
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;
	
	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);
	
	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }
	
	        context.method = "throw";
	        context.arg = new TypeError("The iterator does not provide a 'throw' method");
	      }
	
	      return ContinueSentinel;
	    }
	
	    var record = tryCatch(method, delegate.iterator, context.arg);
	
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    var info = record.arg;
	
	    if (!info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;
	
	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;
	
	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }
	
	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function () {
	    return this;
	  };
	
	  Gp.toString = function () {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function (object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	            next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.method = "next";
	      this.arg = undefined;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function stop() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }
	
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	
	      return this.complete(record);
	    },
	
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	
	      return ContinueSentinel;
	    },
	
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }
	
	      return ContinueSentinel;
	    }
	  };
	}(
	// Among the various tricks for obtaining a reference to the global
	// object, this seems to be the most reliable technique that does not
	// use indirect eval (which violates Content Security Policy).
	(typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(295)(module)))

/***/ }),
/* 295 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(297);
	module.exports = __webpack_require__(10).RegExp.escape;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(9),
	    $re = __webpack_require__(298)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', { escape: function escape(it) {
	    return $re(it);
	  } });

/***/ }),
/* 298 */
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (regExp, replace) {
	  var replacer = replace === Object(replace) ? function (part) {
	    return replace[part];
	  } : replace;
	  return function (it) {
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * Vue.js v2.3.4
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	/*  */
	
	// these helpers produces better vm code in JS engines due to their
	// explicitness and function inlining
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isUndef(v) {
	  return v === undefined || v === null;
	}
	
	function isDef(v) {
	  return v !== undefined && v !== null;
	}
	
	function isTrue(v) {
	  return v === true;
	}
	
	function isFalse(v) {
	  return v === false;
	}
	/**
	 * Check if value is primitive
	 */
	function isPrimitive(value) {
	  return typeof value === 'string' || typeof value === 'number';
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	var _toString = Object.prototype.toString;
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	  return _toString.call(obj) === '[object Object]';
	}
	
	function isRegExp(v) {
	  return _toString.call(v) === '[object RegExp]';
	}
	
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
	}
	
	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	  var n = parseFloat(val);
	  return isNaN(n) ? val : n;
	}
	
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase ? function (val) {
	    return map[val.toLowerCase()];
	  } : function (val) {
	    return map[val];
	  };
	}
	
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	
	/**
	 * Remove an item from an array
	 */
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) {
	    return c ? c.toUpperCase() : '';
	  });
	});
	
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	});
	
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	/**
	 * Simple bind, faster than native
	 */
	function bind(fn, ctx) {
	  function boundFn(a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn;
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to;
	}
	
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Perform no operation.
	 */
	function noop() {}
	
	/**
	 * Always return false.
	 */
	var no = function no() {
	  return false;
	};
	
	/**
	 * Return same value
	 */
	var identity = function identity(_) {
	  return _;
	};
	
	/**
	 * Generate a static keys string from compiler modules.
	 */
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	  var isObjectA = isObject(a);
	  var isObjectB = isObject(b);
	  if (isObjectA && isObjectB) {
	    try {
	      return JSON.stringify(a) === JSON.stringify(b);
	    } catch (e) {
	      // possible circular reference
	      return a === b;
	    }
	  } else if (!isObjectA && !isObjectB) {
	    return String(a) === String(b);
	  } else {
	    return false;
	  }
	}
	
	function looseIndexOf(arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	/**
	 * Ensure a function is called only once.
	 */
	function once(fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(this, arguments);
	    }
	  };
	}
	
	var SSR_ATTR = 'data-server-rendered';
	
	var ASSET_TYPES = ['component', 'directive', 'filter'];
	
	var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];
	
	/*  */
	
	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),
	
	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,
	
	  /**
	   * Show production mode tip message on boot?
	   */
	  productionTip: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to enable devtools
	   */
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Whether to record perf
	   */
	  performance: false,
	
	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,
	
	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: [],
	
	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),
	
	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,
	
	  /**
	   * Check if an attribute is reserved so that it cannot be used as a component
	   * prop. This is platform-dependent and may be overwritten.
	   */
	  isReservedAttr: no,
	
	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,
	
	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,
	
	  /**
	   * Parse the real tag name for the specific platform.
	   */
	  parsePlatformTagName: identity,
	
	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,
	
	  /**
	   * Exposed for legacy reasons
	   */
	  _lifecycleHooks: LIFECYCLE_HOOKS
	};
	
	/*  */
	
	var emptyObject = Object.freeze({});
	
	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath(path) {
	  if (bailRE.test(path)) {
	    return;
	  }
	  var segments = path.split('.');
	  return function (obj) {
	    for (var i = 0; i < segments.length; i++) {
	      if (!obj) {
	        return;
	      }
	      obj = obj[segments[i]];
	    }
	    return obj;
	  };
	}
	
	/*  */
	
	var warn = noop;
	var tip = noop;
	var formatComponentName = null; // work around flow check
	
	if (process.env.NODE_ENV !== 'production') {
	  var hasConsole = typeof console !== 'undefined';
	  var classifyRE = /(?:^|[-_])(\w)/g;
	  var classify = function classify(str) {
	    return str.replace(classifyRE, function (c) {
	      return c.toUpperCase();
	    }).replace(/[-_]/g, '');
	  };
	
	  warn = function warn(msg, vm) {
	    if (hasConsole && !config.silent) {
	      console.error("[Vue warn]: " + msg + (vm ? generateComponentTrace(vm) : ''));
	    }
	  };
	
	  tip = function tip(msg, vm) {
	    if (hasConsole && !config.silent) {
	      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
	    }
	  };
	
	  formatComponentName = function formatComponentName(vm, includeFile) {
	    if (vm.$root === vm) {
	      return '<Root>';
	    }
	    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;
	
	    var file = vm._isVue && vm.$options.__file;
	    if (!name && file) {
	      var match = file.match(/([^/\\]+)\.vue$/);
	      name = match && match[1];
	    }
	
	    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
	  };
	
	  var repeat = function repeat(str, n) {
	    var res = '';
	    while (n) {
	      if (n % 2 === 1) {
	        res += str;
	      }
	      if (n > 1) {
	        str += str;
	      }
	      n >>= 1;
	    }
	    return res;
	  };
	
	  var generateComponentTrace = function generateComponentTrace(vm) {
	    if (vm._isVue && vm.$parent) {
	      var tree = [];
	      var currentRecursiveSequence = 0;
	      while (vm) {
	        if (tree.length > 0) {
	          var last = tree[tree.length - 1];
	          if (last.constructor === vm.constructor) {
	            currentRecursiveSequence++;
	            vm = vm.$parent;
	            continue;
	          } else if (currentRecursiveSequence > 0) {
	            tree[tree.length - 1] = [last, currentRecursiveSequence];
	            currentRecursiveSequence = 0;
	          }
	        }
	        tree.push(vm);
	        vm = vm.$parent;
	      }
	      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
	        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
	      }).join('\n');
	    } else {
	      return "\n\n(found in " + formatComponentName(vm) + ")";
	    }
	  };
	}
	
	/*  */
	
	function handleError(err, vm, info) {
	  if (config.errorHandler) {
	    config.errorHandler.call(null, err, vm, info);
	  } else {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
	    }
	    /* istanbul ignore else */
	    if (inBrowser && typeof console !== 'undefined') {
	      console.error(err);
	    } else {
	      throw err;
	    }
	  }
	}
	
	/*  */
	/* globals MutationObserver */
	
	// can we use __proto__?
	var hasProto = '__proto__' in {};
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
	var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
	
	var supportsPassive = false;
	if (inBrowser) {
	  try {
	    var opts = {};
	    Object.defineProperty(opts, 'passive', {
	      get: function get() {
	        /* istanbul ignore next */
	        supportsPassive = true;
	      }
	    }); // https://github.com/facebook/flow/issues/285
	    window.addEventListener('test-passive', null, opts);
	  } catch (e) {}
	}
	
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function isServerRendering() {
	  if (_isServer === undefined) {
	    /* istanbul ignore if */
	    if (!inBrowser && typeof global !== 'undefined') {
	      // detect presence of vue-server-renderer and avoid
	      // Webpack shimming the process
	      _isServer = global['process'].env.VUE_ENV === 'server';
	    } else {
	      _isServer = false;
	    }
	  }
	  return _isServer;
	};
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	/* istanbul ignore next */
	function isNative(Ctor) {
	  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	
	var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
	
	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    var logError = function logError(err) {
	      console.error(err);
	    };
	    timerFunc = function timerFunc() {
	      p.then(nextTickHandler).catch(logError);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) {
	        setTimeout(noop);
	      }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
	  // PhantomJS and iOS 7.x
	  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function timerFunc() {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function timerFunc() {
	      setTimeout(nextTickHandler, 0);
	    };
	  }
	
	  return function queueNextTick(cb, ctx) {
	    var _resolve;
	    callbacks.push(function () {
	      if (cb) {
	        try {
	          cb.call(ctx);
	        } catch (e) {
	          handleError(e, ctx, 'nextTick');
	        }
	      } else if (_resolve) {
	        _resolve(ctx);
	      }
	    });
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	    if (!cb && typeof Promise !== 'undefined') {
	      return new Promise(function (resolve, reject) {
	        _resolve = resolve;
	      });
	    }
	  };
	}();
	
	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    function Set() {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has(key) {
	      return this.set[key] === true;
	    };
	    Set.prototype.add = function add(key) {
	      this.set[key] = true;
	    };
	    Set.prototype.clear = function clear() {
	      this.set = Object.create(null);
	    };
	
	    return Set;
	  }();
	}
	
	/*  */
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	};
	
	Dep.prototype.addSub = function addSub(sub) {
	  this.subs.push(sub);
	};
	
	Dep.prototype.removeSub = function removeSub(sub) {
	  remove(this.subs, sub);
	};
	
	Dep.prototype.depend = function depend() {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};
	
	Dep.prototype.notify = function notify() {
	  // stabilize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];
	
	function pushTarget(_target) {
	  if (Dep.target) {
	    targetStack.push(Dep.target);
	  }
	  Dep.target = _target;
	}
	
	function popTarget() {
	  Dep.target = targetStack.pop();
	}
	
	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    var arguments$1 = arguments;
	
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments$1[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) {
	      ob.observeArray(inserted);
	    }
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/*  */
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true,
	  isSettingProps: false
	};
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk(obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray(items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 */
	/* istanbul ignore next */
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, asRootData) {
	  if (!isObject(value)) {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (asRootData && ob) {
	    ob.vmCount++;
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1(obj, key, val, customSetter) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      /* eslint-disable no-self-compare */
	      if (newVal === value || newVal !== newVal && value !== value) {
	        return;
	      }
	      /* eslint-enable no-self-compare */
	      if (process.env.NODE_ENV !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set(target, key, val) {
	  if (Array.isArray(target) && typeof key === 'number') {
	    target.length = Math.max(target.length, key);
	    target.splice(key, 1, val);
	    return val;
	  }
	  if (hasOwn(target, key)) {
	    target[key] = val;
	    return val;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
	    return val;
	  }
	  if (!ob) {
	    target[key] = val;
	    return val;
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del(target, key) {
	  if (Array.isArray(target) && typeof key === 'number') {
	    target.splice(key, 1);
	    return;
	  }
	  var ob = target.__ob__;
	  if (target._isVue || ob && ob.vmCount) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
	    return;
	  }
	  if (!hasOwn(target, key)) {
	    return;
	  }
	  delete target[key];
	  if (!ob) {
	    return;
	  }
	  ob.dep.notify();
	}
	
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value) {
	  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;
	
	/**
	 * Options with restrictions
	 */
	if (process.env.NODE_ENV !== 'production') {
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
	    }
	    return defaultStrat(parent, child);
	  };
	}
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData(to, from) {
	  if (!from) {
	    return to;
	  }
	  var key, toVal, fromVal;
	  var keys = Object.keys(from);
	  for (var i = 0; i < keys.length; i++) {
	    key = keys[i];
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * Hooks and props are merged as arrays.
	 */
	function mergeHook(parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
	}
	
	LIFECYCLE_HOOKS.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, childVal) : res;
	}
	
	ASSET_TYPES.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  /* istanbul ignore if */
	  if (!childVal) {
	    return Object.create(parentVal || null);
	  }
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) {
	    return Object.create(parentVal || null);
	  }
	  if (!parentVal) {
	    return childVal;
	  }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Validate component names
	 */
	function checkComponents(options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps(options) {
	  var props = options.props;
	  if (!props) {
	    return;
	  }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val) ? val : { type: val };
	    }
	  }
	  options.props = res;
	}
	
	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives(options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions(parent, child, vm) {
	  if (process.env.NODE_ENV !== 'production') {
	    checkComponents(child);
	  }
	
	  if (typeof child === 'function') {
	    child = child.options;
	  }
	
	  normalizeProps(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  // check local registration variations first
	  if (hasOwn(assets, id)) {
	    return assets[id];
	  }
	  var camelizedId = camelize(id);
	  if (hasOwn(assets, camelizedId)) {
	    return assets[camelizedId];
	  }
	  var PascalCaseId = capitalize(camelizedId);
	  if (hasOwn(assets, PascalCaseId)) {
	    return assets[PascalCaseId];
	  }
	  // fallback to prototype chain
	  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	/*  */
	
	function validateProp(key, propOptions, propsData, vm) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isType(Boolean, prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value;
	}
	
	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue(vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined;
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
	    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
	    return vm._props[key];
	  }
	  // call factory function for non-Function types
	  // a value is Function if its prototype is function even across different execution context
	  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp(prop, name, value, vm, absent) {
	  if (prop.required && absent) {
	    warn('Missing required prop: "' + name + '"', vm);
	    return;
	  }
	  if (value == null && !prop.required) {
	    return;
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType || '');
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
	    return;
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
	    }
	  }
	}
	
	var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
	
	function assertType(value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (simpleCheckRE.test(expectedType)) {
	    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType(fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match ? match[1] : '';
	}
	
	function isType(type, fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === getType(type);
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === getType(type)) {
	      return true;
	    }
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	/*  */
	
	/* not type checking this file because flow doesn't play well with Proxy */
	
	var initProxy;
	
	if (process.env.NODE_ENV !== 'production') {
	  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
	  );
	
	  var warnNonPresent = function warnNonPresent(target, key) {
	    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
	  };
	
	  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);
	
	  if (hasProxy) {
	    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
	    config.keyCodes = new Proxy(config.keyCodes, {
	      set: function set(target, key, value) {
	        if (isBuiltInModifier(key)) {
	          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
	          return false;
	        } else {
	          target[key] = value;
	          return true;
	        }
	      }
	    });
	  }
	
	  var hasHandler = {
	    has: function has(target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warnNonPresent(target, key);
	      }
	      return has || !isAllowed;
	    }
	  };
	
	  var getHandler = {
	    get: function get(target, key) {
	      if (typeof key === 'string' && !(key in target)) {
	        warnNonPresent(target, key);
	      }
	      return target[key];
	    }
	  };
	
	  initProxy = function initProxy(vm) {
	    if (hasProxy) {
	      // determine which proxy handler to use
	      var options = vm.$options;
	      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
	      vm._renderProxy = new Proxy(vm, handlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}
	
	var mark;
	var measure;
	
	if (process.env.NODE_ENV !== 'production') {
	  var perf = inBrowser && window.performance;
	  /* istanbul ignore if */
	  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
	    mark = function mark(tag) {
	      return perf.mark(tag);
	    };
	    measure = function measure(name, startTag, endTag) {
	      perf.measure(name, startTag, endTag);
	      perf.clearMarks(startTag);
	      perf.clearMarks(endTag);
	      perf.clearMeasures(name);
	    };
	  }
	}
	
	/*  */
	
	var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = undefined;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.componentInstance = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	};
	
	var prototypeAccessors = { child: {} };
	
	// DEPRECATED: alias for componentInstance for backwards compat.
	/* istanbul ignore next */
	prototypeAccessors.child.get = function () {
	  return this.componentInstance;
	};
	
	Object.defineProperties(VNode.prototype, prototypeAccessors);
	
	var createEmptyVNode = function createEmptyVNode() {
	  var node = new VNode();
	  node.text = '';
	  node.isComment = true;
	  return node;
	};
	
	function createTextVNode(val) {
	  return new VNode(undefined, undefined, undefined, String(val));
	}
	
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
	  cloned.ns = vnode.ns;
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isComment = vnode.isComment;
	  cloned.isCloned = true;
	  return cloned;
	}
	
	function cloneVNodes(vnodes) {
	  var len = vnodes.length;
	  var res = new Array(len);
	  for (var i = 0; i < len; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res;
	}
	
	/*  */
	
	var normalizeEvent = cached(function (name) {
	  var passive = name.charAt(0) === '&';
	  name = passive ? name.slice(1) : name;
	  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
	  name = once$$1 ? name.slice(1) : name;
	  var capture = name.charAt(0) === '!';
	  name = capture ? name.slice(1) : name;
	  return {
	    name: name,
	    once: once$$1,
	    capture: capture,
	    passive: passive
	  };
	});
	
	function createFnInvoker(fns) {
	  function invoker() {
	    var arguments$1 = arguments;
	
	    var fns = invoker.fns;
	    if (Array.isArray(fns)) {
	      for (var i = 0; i < fns.length; i++) {
	        fns[i].apply(null, arguments$1);
	      }
	    } else {
	      // return handler return value for single handlers
	      return fns.apply(null, arguments);
	    }
	  }
	  invoker.fns = fns;
	  return invoker;
	}
	
	function updateListeners(on, oldOn, add, remove$$1, vm) {
	  var name, cur, old, event;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    event = normalizeEvent(name);
	    if (isUndef(cur)) {
	      process.env.NODE_ENV !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
	    } else if (isUndef(old)) {
	      if (isUndef(cur.fns)) {
	        cur = on[name] = createFnInvoker(cur);
	      }
	      add(event.name, cur, event.once, event.capture, event.passive);
	    } else if (cur !== old) {
	      old.fns = cur;
	      on[name] = old;
	    }
	  }
	  for (name in oldOn) {
	    if (isUndef(on[name])) {
	      event = normalizeEvent(name);
	      remove$$1(event.name, oldOn[name], event.capture);
	    }
	  }
	}
	
	/*  */
	
	function mergeVNodeHook(def, hookKey, hook) {
	  var invoker;
	  var oldHook = def[hookKey];
	
	  function wrappedHook() {
	    hook.apply(this, arguments);
	    // important: remove merged hook to ensure it's called only once
	    // and prevent memory leak
	    remove(invoker.fns, wrappedHook);
	  }
	
	  if (isUndef(oldHook)) {
	    // no existing hook
	    invoker = createFnInvoker([wrappedHook]);
	  } else {
	    /* istanbul ignore if */
	    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
	      // already a merged invoker
	      invoker = oldHook;
	      invoker.fns.push(wrappedHook);
	    } else {
	      // existing plain hook
	      invoker = createFnInvoker([oldHook, wrappedHook]);
	    }
	  }
	
	  invoker.merged = true;
	  def[hookKey] = invoker;
	}
	
	/*  */
	
	function extractPropsFromVNodeData(data, Ctor, tag) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (isUndef(propOptions)) {
	    return;
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  if (isDef(attrs) || isDef(props)) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      if (process.env.NODE_ENV !== 'production') {
	        var keyInLowerCase = key.toLowerCase();
	        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
	          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
	        }
	      }
	      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
	    }
	  }
	  return res;
	}
	
	function checkProp(res, hash, key, altKey, preserve) {
	  if (isDef(hash)) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true;
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true;
	    }
	  }
	  return false;
	}
	
	/*  */
	
	// The template compiler attempts to minimize the need for normalization by
	// statically analyzing the template at compile time.
	//
	// For plain HTML markup, normalization can be completely skipped because the
	// generated render function is guaranteed to return Array<VNode>. There are
	// two cases where extra normalization is needed:
	
	// 1. When the children contains components - because a functional component
	// may return an Array instead of a single root. In this case, just a simple
	// normalization is needed - if any child is an Array, we flatten the whole
	// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
	// because functional components already normalize their own children.
	function simpleNormalizeChildren(children) {
	  for (var i = 0; i < children.length; i++) {
	    if (Array.isArray(children[i])) {
	      return Array.prototype.concat.apply([], children);
	    }
	  }
	  return children;
	}
	
	// 2. When the children contains constructs that always generated nested Arrays,
	// e.g. <template>, <slot>, v-for, or when the children is provided by user
	// with hand-written render functions / JSX. In such cases a full normalization
	// is needed to cater to all possible types of children values.
	function normalizeChildren(children) {
	  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
	}
	
	function isTextNode(node) {
	  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
	}
	
	function normalizeArrayChildren(children, nestedIndex) {
	  var res = [];
	  var i, c, last;
	  for (i = 0; i < children.length; i++) {
	    c = children[i];
	    if (isUndef(c) || typeof c === 'boolean') {
	      continue;
	    }
	    last = res[res.length - 1];
	    //  nested
	    if (Array.isArray(c)) {
	      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
	    } else if (isPrimitive(c)) {
	      if (isTextNode(last)) {
	        // merge adjacent text nodes
	        // this is necessary for SSR hydration because text nodes are
	        // essentially merged when rendered to HTML strings
	        last.text += String(c);
	      } else if (c !== '') {
	        // convert primitive to vnode
	        res.push(createTextVNode(c));
	      }
	    } else {
	      if (isTextNode(c) && isTextNode(last)) {
	        // merge adjacent text nodes
	        res[res.length - 1] = createTextVNode(last.text + c.text);
	      } else {
	        // default key for nested array children (likely generated by v-for)
	        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
	          c.key = "__vlist" + nestedIndex + "_" + i + "__";
	        }
	        res.push(c);
	      }
	    }
	  }
	  return res;
	}
	
	/*  */
	
	function ensureCtor(comp, base) {
	  return isObject(comp) ? base.extend(comp) : comp;
	}
	
	function resolveAsyncComponent(factory, baseCtor, context) {
	  if (isTrue(factory.error) && isDef(factory.errorComp)) {
	    return factory.errorComp;
	  }
	
	  if (isDef(factory.resolved)) {
	    return factory.resolved;
	  }
	
	  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
	    return factory.loadingComp;
	  }
	
	  if (isDef(factory.contexts)) {
	    // already pending
	    factory.contexts.push(context);
	  } else {
	    var contexts = factory.contexts = [context];
	    var sync = true;
	
	    var forceRender = function forceRender() {
	      for (var i = 0, l = contexts.length; i < l; i++) {
	        contexts[i].$forceUpdate();
	      }
	    };
	
	    var resolve = once(function (res) {
	      // cache resolved
	      factory.resolved = ensureCtor(res, baseCtor);
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        forceRender();
	      }
	    });
	
	    var reject = once(function (reason) {
	      process.env.NODE_ENV !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
	      if (isDef(factory.errorComp)) {
	        factory.error = true;
	        forceRender();
	      }
	    });
	
	    var res = factory(resolve, reject);
	
	    if (isObject(res)) {
	      if (typeof res.then === 'function') {
	        // () => Promise
	        if (isUndef(factory.resolved)) {
	          res.then(resolve, reject);
	        }
	      } else if (isDef(res.component) && typeof res.component.then === 'function') {
	        res.component.then(resolve, reject);
	
	        if (isDef(res.error)) {
	          factory.errorComp = ensureCtor(res.error, baseCtor);
	        }
	
	        if (isDef(res.loading)) {
	          factory.loadingComp = ensureCtor(res.loading, baseCtor);
	          if (res.delay === 0) {
	            factory.loading = true;
	          } else {
	            setTimeout(function () {
	              if (isUndef(factory.resolved) && isUndef(factory.error)) {
	                factory.loading = true;
	                forceRender();
	              }
	            }, res.delay || 200);
	          }
	        }
	
	        if (isDef(res.timeout)) {
	          setTimeout(function () {
	            if (isUndef(factory.resolved)) {
	              reject(process.env.NODE_ENV !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
	            }
	          }, res.timeout);
	        }
	      }
	    }
	
	    sync = false;
	    // return in case resolved synchronously
	    return factory.loading ? factory.loadingComp : factory.resolved;
	  }
	}
	
	/*  */
	
	function getFirstComponentChild(children) {
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      var c = children[i];
	      if (isDef(c) && isDef(c.componentOptions)) {
	        return c;
	      }
	    }
	  }
	}
	
	/*  */
	
	/*  */
	
	function initEvents(vm) {
	  vm._events = Object.create(null);
	  vm._hasHookEvent = false;
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  if (listeners) {
	    updateComponentListeners(vm, listeners);
	  }
	}
	
	var target;
	
	function add(event, fn, once$$1) {
	  if (once$$1) {
	    target.$once(event, fn);
	  } else {
	    target.$on(event, fn);
	  }
	}
	
	function remove$1(event, fn) {
	  target.$off(event, fn);
	}
	
	function updateComponentListeners(vm, listeners, oldListeners) {
	  target = vm;
	  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
	}
	
	function eventsMixin(Vue) {
	  var hookRE = /^hook:/;
	  Vue.prototype.$on = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    if (Array.isArray(event)) {
	      for (var i = 0, l = event.length; i < l; i++) {
	        this$1.$on(event[i], fn);
	      }
	    } else {
	      (vm._events[event] || (vm._events[event] = [])).push(fn);
	      // optimize hook:event cost by using a boolean flag marked at registration
	      // instead of a hash lookup
	      if (hookRE.test(event)) {
	        vm._hasHookEvent = true;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on() {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm;
	  };
	
	  Vue.prototype.$off = function (event, fn) {
	    var this$1 = this;
	
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm;
	    }
	    // array of events
	    if (Array.isArray(event)) {
	      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
	        this$1.$off(event[i$1], fn);
	      }
	      return vm;
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm;
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return vm;
	  };
	
	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    if (process.env.NODE_ENV !== 'production') {
	      var lowerCaseEvent = event.toLowerCase();
	      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
	        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
	      }
	    }
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        cbs[i].apply(vm, args);
	      }
	    }
	    return vm;
	  };
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving raw children VNodes into a slot object.
	 */
	function resolveSlots(children, context) {
	  var slots = {};
	  if (!children) {
	    return slots;
	  }
	  var defaultSlot = [];
	  for (var i = 0, l = children.length; i < l; i++) {
	    var child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
	      var name = child.data.slot;
	      var slot = slots[name] || (slots[name] = []);
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore whitespace
	  if (!defaultSlot.every(isWhitespace)) {
	    slots.default = defaultSlot;
	  }
	  return slots;
	}
	
	function isWhitespace(node) {
	  return node.isComment || node.text === ' ';
	}
	
	function resolveScopedSlots(fns, // see flow/vnode
	res) {
	  res = res || {};
	  for (var i = 0; i < fns.length; i++) {
	    if (Array.isArray(fns[i])) {
	      resolveScopedSlots(fns[i], res);
	    } else {
	      res[fns[i].key] = fns[i].fn;
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var activeInstance = null;
	
	function initLifecycle(vm) {
	  var options = vm.$options;
	
	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }
	
	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;
	
	  vm.$children = [];
	  vm.$refs = {};
	
	  vm._watcher = null;
	  vm._inactive = null;
	  vm._directInactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}
	
	function lifecycleMixin(Vue) {
	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevVnode = vm._vnode;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    vm._vnode = vnode;
	    // Vue.prototype.__patch__ is injected in entry points
	    // based on the rendering backend used.
	    if (!prevVnode) {
	      // initial render
	      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
	      , vm.$options._parentElm, vm.$options._refElm);
	    } else {
	      // updates
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    // updated hook is called by the scheduler to ensure that children are
	    // updated in a parent's updated hook.
	  };
	
	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };
	
	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return;
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	    // fire destroyed hook
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	    // remove reference to DOM nodes (prevents leak)
	    vm.$options._parentElm = vm.$options._refElm = null;
	  };
	}
	
	function mountComponent(vm, el, hydrating) {
	  vm.$el = el;
	  if (!vm.$options.render) {
	    vm.$options.render = createEmptyVNode;
	    if (process.env.NODE_ENV !== 'production') {
	      /* istanbul ignore if */
	      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
	        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
	      } else {
	        warn('Failed to mount component: template or render function not defined.', vm);
	      }
	    }
	  }
	  callHook(vm, 'beforeMount');
	
	  var updateComponent;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	    updateComponent = function updateComponent() {
	      var name = vm._name;
	      var id = vm._uid;
	      var startTag = "vue-perf-start:" + id;
	      var endTag = "vue-perf-end:" + id;
	
	      mark(startTag);
	      var vnode = vm._render();
	      mark(endTag);
	      measure(name + " render", startTag, endTag);
	
	      mark(startTag);
	      vm._update(vnode, hydrating);
	      mark(endTag);
	      measure(name + " patch", startTag, endTag);
	    };
	  } else {
	    updateComponent = function updateComponent() {
	      vm._update(vm._render(), hydrating);
	    };
	  }
	
	  vm._watcher = new Watcher(vm, updateComponent, noop);
	  hydrating = false;
	
	  // manually mounted instance, call mounted on self
	  // mounted is called for render-created child components in its inserted hook
	  if (vm.$vnode == null) {
	    vm._isMounted = true;
	    callHook(vm, 'mounted');
	  }
	  return vm;
	}
	
	function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
	  // determine whether component has slot children
	  // we need to do this before overwriting $options._renderChildren
	  var hasChildren = !!(renderChildren || // has new static slots
	  vm.$options._renderChildren || // has old static slots
	  parentVnode.data.scopedSlots || // has new scoped slots
	  vm.$scopedSlots !== emptyObject // has old scoped slots
	  );
	
	  vm.$options._parentVnode = parentVnode;
	  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
	  if (vm._vnode) {
	    // update child tree's parent
	    vm._vnode.parent = parentVnode;
	  }
	  vm.$options._renderChildren = renderChildren;
	
	  // update props
	  if (propsData && vm.$options.props) {
	    observerState.shouldConvert = false;
	    if (process.env.NODE_ENV !== 'production') {
	      observerState.isSettingProps = true;
	    }
	    var props = vm._props;
	    var propKeys = vm.$options._propKeys || [];
	    for (var i = 0; i < propKeys.length; i++) {
	      var key = propKeys[i];
	      props[key] = validateProp(key, vm.$options.props, propsData, vm);
	    }
	    observerState.shouldConvert = true;
	    if (process.env.NODE_ENV !== 'production') {
	      observerState.isSettingProps = false;
	    }
	    // keep a copy of raw propsData
	    vm.$options.propsData = propsData;
	  }
	  // update listeners
	  if (listeners) {
	    var oldListeners = vm.$options._parentListeners;
	    vm.$options._parentListeners = listeners;
	    updateComponentListeners(vm, listeners, oldListeners);
	  }
	  // resolve slots + force update if has children
	  if (hasChildren) {
	    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
	    vm.$forceUpdate();
	  }
	}
	
	function isInInactiveTree(vm) {
	  while (vm && (vm = vm.$parent)) {
	    if (vm._inactive) {
	      return true;
	    }
	  }
	  return false;
	}
	
	function activateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = false;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  } else if (vm._directInactive) {
	    return;
	  }
	  if (vm._inactive || vm._inactive === null) {
	    vm._inactive = false;
	    for (var i = 0; i < vm.$children.length; i++) {
	      activateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'activated');
	  }
	}
	
	function deactivateChildComponent(vm, direct) {
	  if (direct) {
	    vm._directInactive = true;
	    if (isInInactiveTree(vm)) {
	      return;
	    }
	  }
	  if (!vm._inactive) {
	    vm._inactive = true;
	    for (var i = 0; i < vm.$children.length; i++) {
	      deactivateChildComponent(vm.$children[i]);
	    }
	    callHook(vm, 'deactivated');
	  }
	}
	
	function callHook(vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      try {
	        handlers[i].call(vm);
	      } catch (e) {
	        handleError(e, vm, hook + " hook");
	      }
	    }
	  }
	  if (vm._hasHookEvent) {
	    vm.$emit('hook:' + hook);
	  }
	}
	
	/*  */
	
	var MAX_UPDATE_COUNT = 100;
	
	var queue = [];
	var activatedChildren = [];
	var has = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;
	
	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState() {
	  index = queue.length = activatedChildren.length = 0;
	  has = {};
	  if (process.env.NODE_ENV !== 'production') {
	    circular = {};
	  }
	  waiting = flushing = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue() {
	  flushing = true;
	  var watcher, id;
	
	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) {
	    return a.id - b.id;
	  });
	
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    watcher = queue[index];
	    id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > MAX_UPDATE_COUNT) {
	        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
	        break;
	      }
	    }
	  }
	
	  // keep copies of post queues before resetting state
	  var activatedQueue = activatedChildren.slice();
	  var updatedQueue = queue.slice();
	
	  resetSchedulerState();
	
	  // call component updated and activated hooks
	  callActivatedHooks(activatedQueue);
	  callUpdateHooks(updatedQueue);
	
	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }
	}
	
	function callUpdateHooks(queue) {
	  var i = queue.length;
	  while (i--) {
	    var watcher = queue[i];
	    var vm = watcher.vm;
	    if (vm._watcher === watcher && vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  }
	}
	
	/**
	 * Queue a kept-alive component that was activated during patch.
	 * The queue will be processed after the entire tree has been patched.
	 */
	function queueActivatedComponent(vm) {
	  // setting _inactive to false here so that a render function can
	  // rely on checking whether it's in an inactive tree (e.g. router-view)
	  vm._inactive = false;
	  activatedChildren.push(vm);
	}
	
	function callActivatedHooks(queue) {
	  for (var i = 0; i < queue.length; i++) {
	    queue[i]._inactive = true;
	    activateChildComponent(queue[i], true /* true */);
	  }
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    has[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i > index && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(i + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}
	
	/*  */
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher(vm, expOrFn, cb, options) {
	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  if (options) {
	    this.deep = !!options.deep;
	    this.user = !!options.user;
	    this.lazy = !!options.lazy;
	    this.sync = !!options.sync;
	  } else {
	    this.deep = this.user = this.lazy = this.sync = false;
	  }
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	};
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get() {
	  pushTarget(this);
	  var value;
	  var vm = this.vm;
	  if (this.user) {
	    try {
	      value = this.getter.call(vm, vm);
	    } catch (e) {
	      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
	    }
	  } else {
	    value = this.getter.call(vm, vm);
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  popTarget();
	  this.cleanupDeps();
	  return value;
	};
	
	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep(dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update() {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};
	
	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run() {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated.
	    isObject(value) || this.deep) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate() {
	  this.value = this.get();
	  this.dirty = false;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend() {
	  var this$1 = this;
	
	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown() {
	  var this$1 = this;
	
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed.
	    if (!this.vm._isBeingDestroyed) {
	      remove(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};
	
	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse(val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}
	
	function _traverse(val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
	    return;
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return;
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) {
	      _traverse(val[i], seen);
	    }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      _traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	/*  */
	
	var sharedPropertyDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};
	
	function proxy(target, sourceKey, key) {
	  sharedPropertyDefinition.get = function proxyGetter() {
	    return this[sourceKey][key];
	  };
	  sharedPropertyDefinition.set = function proxySetter(val) {
	    this[sourceKey][key] = val;
	  };
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function initState(vm) {
	  vm._watchers = [];
	  var opts = vm.$options;
	  if (opts.props) {
	    initProps(vm, opts.props);
	  }
	  if (opts.methods) {
	    initMethods(vm, opts.methods);
	  }
	  if (opts.data) {
	    initData(vm);
	  } else {
	    observe(vm._data = {}, true /* asRootData */);
	  }
	  if (opts.computed) {
	    initComputed(vm, opts.computed);
	  }
	  if (opts.watch) {
	    initWatch(vm, opts.watch);
	  }
	}
	
	var isReservedProp = {
	  key: 1,
	  ref: 1,
	  slot: 1
	};
	
	function initProps(vm, propsOptions) {
	  var propsData = vm.$options.propsData || {};
	  var props = vm._props = {};
	  // cache prop keys so that future props updates can iterate using Array
	  // instead of dynamic object key enumeration.
	  var keys = vm.$options._propKeys = [];
	  var isRoot = !vm.$parent;
	  // root instance props should be converted
	  observerState.shouldConvert = isRoot;
	  var loop = function loop(key) {
	    keys.push(key);
	    var value = validateProp(key, propsOptions, propsData, vm);
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      if (isReservedProp[key] || config.isReservedAttr(key)) {
	        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
	      }
	      defineReactive$$1(props, key, value, function () {
	        if (vm.$parent && !observerState.isSettingProps) {
	          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
	        }
	      });
	    } else {
	      defineReactive$$1(props, key, value);
	    }
	    // static props are already proxied on the component's prototype
	    // during Vue.extend(). We only need to proxy props defined at
	    // instantiation here.
	    if (!(key in vm)) {
	      proxy(vm, "_props", key);
	    }
	  };
	
	  for (var key in propsOptions) {
	    loop(key);
	  }observerState.shouldConvert = true;
	}
	
	function initData(vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var i = keys.length;
	  while (i--) {
	    if (props && hasOwn(props, keys[i])) {
	      process.env.NODE_ENV !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
	    } else if (!isReserved(keys[i])) {
	      proxy(vm, "_data", keys[i]);
	    }
	  }
	  // observe data
	  observe(data, true /* asRootData */);
	}
	
	function getData(data, vm) {
	  try {
	    return data.call(vm);
	  } catch (e) {
	    handleError(e, vm, "data()");
	    return {};
	  }
	}
	
	var computedWatcherOptions = { lazy: true };
	
	function initComputed(vm, computed) {
	  var watchers = vm._computedWatchers = Object.create(null);
	
	  for (var key in computed) {
	    var userDef = computed[key];
	    var getter = typeof userDef === 'function' ? userDef : userDef.get;
	    if (process.env.NODE_ENV !== 'production') {
	      if (getter === undefined) {
	        warn("No getter function has been defined for computed property \"" + key + "\".", vm);
	        getter = noop;
	      }
	    }
	    // create internal watcher for the computed property.
	    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
	
	    // component-defined computed properties are already defined on the
	    // component prototype. We only need to define computed properties defined
	    // at instantiation here.
	    if (!(key in vm)) {
	      defineComputed(vm, key, userDef);
	    } else if (process.env.NODE_ENV !== 'production') {
	      if (key in vm.$data) {
	        warn("The computed property \"" + key + "\" is already defined in data.", vm);
	      } else if (vm.$options.props && key in vm.$options.props) {
	        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function defineComputed(target, key, userDef) {
	  if (typeof userDef === 'function') {
	    sharedPropertyDefinition.get = createComputedGetter(key);
	    sharedPropertyDefinition.set = noop;
	  } else {
	    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
	    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
	  }
	  Object.defineProperty(target, key, sharedPropertyDefinition);
	}
	
	function createComputedGetter(key) {
	  return function computedGetter() {
	    var watcher = this._computedWatchers && this._computedWatchers[key];
	    if (watcher) {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    }
	  };
	}
	
	function initMethods(vm, methods) {
	  var props = vm.$options.props;
	  for (var key in methods) {
	    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
	    if (process.env.NODE_ENV !== 'production') {
	      if (methods[key] == null) {
	        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
	      }
	      if (props && hasOwn(props, key)) {
	        warn("method \"" + key + "\" has already been defined as a prop.", vm);
	      }
	    }
	  }
	}
	
	function initWatch(vm, watch) {
	  for (var key in watch) {
	    var handler = watch[key];
	    if (Array.isArray(handler)) {
	      for (var i = 0; i < handler.length; i++) {
	        createWatcher(vm, key, handler[i]);
	      }
	    } else {
	      createWatcher(vm, key, handler);
	    }
	  }
	}
	
	function createWatcher(vm, key, handler) {
	  var options;
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  vm.$watch(key, handler, options);
	}
	
	function stateMixin(Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data;
	  };
	  var propsDef = {};
	  propsDef.get = function () {
	    return this._props;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    dataDef.set = function (newData) {
	      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
	    };
	    propsDef.set = function () {
	      warn("$props is readonly.", this);
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);
	  Object.defineProperty(Vue.prototype, '$props', propsDef);
	
	  Vue.prototype.$set = set;
	  Vue.prototype.$delete = del;
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	}
	
	/*  */
	
	function initProvide(vm) {
	  var provide = vm.$options.provide;
	  if (provide) {
	    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
	  }
	}
	
	function initInjections(vm) {
	  var result = resolveInject(vm.$options.inject, vm);
	  if (result) {
	    Object.keys(result).forEach(function (key) {
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        defineReactive$$1(vm, key, result[key], function () {
	          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
	        });
	      } else {
	        defineReactive$$1(vm, key, result[key]);
	      }
	    });
	  }
	}
	
	function resolveInject(inject, vm) {
	  if (inject) {
	    // inject is :any because flow is not smart enough to figure out cached
	    // isArray here
	    var isArray = Array.isArray(inject);
	    var result = Object.create(null);
	    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
	
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var provideKey = isArray ? key : inject[key];
	      var source = vm;
	      while (source) {
	        if (source._provided && provideKey in source._provided) {
	          result[key] = source._provided[provideKey];
	          break;
	        }
	        source = source.$parent;
	      }
	    }
	    return result;
	  }
	}
	
	/*  */
	
	function createFunctionalComponent(Ctor, propsData, data, context, children) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (isDef(propOptions)) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData || {});
	    }
	  } else {
	    if (isDef(data.attrs)) {
	      mergeProps(props, data.attrs);
	    }
	    if (isDef(data.props)) {
	      mergeProps(props, data.props);
	    }
	  }
	  // ensure the createElement function in functional components
	  // gets a unique context - this is necessary for correct named slot check
	  var _context = Object.create(context);
	  var h = function h(a, b, c, d) {
	    return createElement(_context, a, b, c, d, true);
	  };
	  var vnode = Ctor.options.render.call(null, h, {
	    data: data,
	    props: props,
	    children: children,
	    parent: context,
	    listeners: data.on || {},
	    injections: resolveInject(Ctor.options.inject, context),
	    slots: function slots() {
	      return resolveSlots(children, context);
	    }
	  });
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    vnode.functionalOptions = Ctor.options;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode;
	}
	
	function mergeProps(to, from) {
	  for (var key in from) {
	    to[camelize(key)] = from[key];
	  }
	}
	
	/*  */
	
	// hooks to be invoked on component VNodes during patch
	var componentVNodeHooks = {
	  init: function init(vnode, hydrating, parentElm, refElm) {
	    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
	      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
	      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	    } else if (vnode.data.keepAlive) {
	      // kept-alive components, treat as a patch
	      var mountedNode = vnode; // work around flow
	      componentVNodeHooks.prepatch(mountedNode, mountedNode);
	    }
	  },
	
	  prepatch: function prepatch(oldVnode, vnode) {
	    var options = vnode.componentOptions;
	    var child = vnode.componentInstance = oldVnode.componentInstance;
	    updateChildComponent(child, options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	    );
	  },
	
	  insert: function insert(vnode) {
	    var context = vnode.context;
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isMounted) {
	      componentInstance._isMounted = true;
	      callHook(componentInstance, 'mounted');
	    }
	    if (vnode.data.keepAlive) {
	      if (context._isMounted) {
	        // vue-router#1212
	        // During updates, a kept-alive component's child components may
	        // change, so directly walking the tree here may call activated hooks
	        // on incorrect children. Instead we push them into a queue which will
	        // be processed after the whole patch process ended.
	        queueActivatedComponent(componentInstance);
	      } else {
	        activateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  },
	
	  destroy: function destroy(vnode) {
	    var componentInstance = vnode.componentInstance;
	    if (!componentInstance._isDestroyed) {
	      if (!vnode.data.keepAlive) {
	        componentInstance.$destroy();
	      } else {
	        deactivateChildComponent(componentInstance, true /* direct */);
	      }
	    }
	  }
	};
	
	var hooksToMerge = Object.keys(componentVNodeHooks);
	
	function createComponent(Ctor, data, context, children, tag) {
	  if (isUndef(Ctor)) {
	    return;
	  }
	
	  var baseCtor = context.$options._base;
	
	  // plain options object: turn it into a constructor
	  if (isObject(Ctor)) {
	    Ctor = baseCtor.extend(Ctor);
	  }
	
	  // if at this stage it's not a constructor or an async component factory,
	  // reject.
	  if (typeof Ctor !== 'function') {
	    if (process.env.NODE_ENV !== 'production') {
	      warn("Invalid Component definition: " + String(Ctor), context);
	    }
	    return;
	  }
	
	  // async component
	  if (isUndef(Ctor.cid)) {
	    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);
	    if (Ctor === undefined) {
	      // return nothing if this is indeed an async component
	      // wait for the callback to trigger parent update.
	      return;
	    }
	  }
	
	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);
	
	  data = data || {};
	
	  // transform component v-model data into props & events
	  if (isDef(data.model)) {
	    transformModel(Ctor.options, data);
	  }
	
	  // extract props
	  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
	
	  // functional component
	  if (isTrue(Ctor.options.functional)) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children);
	  }
	
	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  data.on = data.nativeOn;
	
	  if (isTrue(Ctor.options.abstract)) {
	    // abstract components do not keep anything
	    // other than props & listeners
	    data = {};
	  }
	
	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);
	
	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
	  return vnode;
	}
	
	function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
	parent, // activeInstance in lifecycle state
	parentElm, refElm) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children,
	    _parentElm: parentElm || null,
	    _refElm: refElm || null
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (isDef(inlineTemplate)) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options);
	}
	
	function mergeHooks(data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = componentVNodeHooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}
	
	function mergeHook$1(one, two) {
	  return function (a, b, c, d) {
	    one(a, b, c, d);
	    two(a, b, c, d);
	  };
	}
	
	// transform component v-model info (value and callback) into
	// prop and event handler respectively.
	function transformModel(options, data) {
	  var prop = options.model && options.model.prop || 'value';
	  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
	  var on = data.on || (data.on = {});
	  if (isDef(on[event])) {
	    on[event] = [data.model.callback].concat(on[event]);
	  } else {
	    on[event] = data.model.callback;
	  }
	}
	
	/*  */
	
	var SIMPLE_NORMALIZE = 1;
	var ALWAYS_NORMALIZE = 2;
	
	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
	  if (Array.isArray(data) || isPrimitive(data)) {
	    normalizationType = children;
	    children = data;
	    data = undefined;
	  }
	  if (isTrue(alwaysNormalize)) {
	    normalizationType = ALWAYS_NORMALIZE;
	  }
	  return _createElement(context, tag, data, children, normalizationType);
	}
	
	function _createElement(context, tag, data, children, normalizationType) {
	  if (isDef(data) && isDef(data.__ob__)) {
	    process.env.NODE_ENV !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
	    return createEmptyVNode();
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return createEmptyVNode();
	  }
	  // support single function children as default scoped slot
	  if (Array.isArray(children) && typeof children[0] === 'function') {
	    data = data || {};
	    data.scopedSlots = { default: children[0] };
	    children.length = 0;
	  }
	  if (normalizationType === ALWAYS_NORMALIZE) {
	    children = normalizeChildren(children);
	  } else if (normalizationType === SIMPLE_NORMALIZE) {
	    children = simpleNormalizeChildren(children);
	  }
	  var vnode, ns;
	  if (typeof tag === 'string') {
	    var Ctor;
	    ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
	    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      vnode = createComponent(Ctor, data, context, children, tag);
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      vnode = new VNode(tag, data, children, undefined, undefined, context);
	    }
	  } else {
	    // direct component options / constructor
	    vnode = createComponent(tag, data, context, children);
	  }
	  if (isDef(vnode)) {
	    if (ns) {
	      applyNS(vnode, ns);
	    }
	    return vnode;
	  } else {
	    return createEmptyVNode();
	  }
	}
	
	function applyNS(vnode, ns) {
	  vnode.ns = ns;
	  if (vnode.tag === 'foreignObject') {
	    // use default namespace inside foreignObject
	    return;
	  }
	  if (isDef(vnode.children)) {
	    for (var i = 0, l = vnode.children.length; i < l; i++) {
	      var child = vnode.children[i];
	      if (isDef(child.tag) && isUndef(child.ns)) {
	        applyNS(child, ns);
	      }
	    }
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering v-for lists.
	 */
	function renderList(val, render) {
	  var ret, i, l, keys, key;
	  if (Array.isArray(val) || typeof val === 'string') {
	    ret = new Array(val.length);
	    for (i = 0, l = val.length; i < l; i++) {
	      ret[i] = render(val[i], i);
	    }
	  } else if (typeof val === 'number') {
	    ret = new Array(val);
	    for (i = 0; i < val; i++) {
	      ret[i] = render(i + 1, i);
	    }
	  } else if (isObject(val)) {
	    keys = Object.keys(val);
	    ret = new Array(keys.length);
	    for (i = 0, l = keys.length; i < l; i++) {
	      key = keys[i];
	      ret[i] = render(val[key], key, i);
	    }
	  }
	  if (isDef(ret)) {
	    ret._isVList = true;
	  }
	  return ret;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering <slot>
	 */
	function renderSlot(name, fallback, props, bindObject) {
	  var scopedSlotFn = this.$scopedSlots[name];
	  if (scopedSlotFn) {
	    // scoped slot
	    props = props || {};
	    if (bindObject) {
	      extend(props, bindObject);
	    }
	    return scopedSlotFn(props) || fallback;
	  } else {
	    var slotNodes = this.$slots[name];
	    // warn duplicate slot usage
	    if (slotNodes && process.env.NODE_ENV !== 'production') {
	      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
	      slotNodes._rendered = true;
	    }
	    return slotNodes || fallback;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for resolving filters
	 */
	function resolveFilter(id) {
	  return resolveAsset(this.$options, 'filters', id, true) || identity;
	}
	
	/*  */
	
	/**
	 * Runtime helper for checking keyCodes from config.
	 */
	function checkKeyCodes(eventKeyCode, key, builtInAlias) {
	  var keyCodes = config.keyCodes[key] || builtInAlias;
	  if (Array.isArray(keyCodes)) {
	    return keyCodes.indexOf(eventKeyCode) === -1;
	  } else {
	    return keyCodes !== eventKeyCode;
	  }
	}
	
	/*  */
	
	/**
	 * Runtime helper for merging v-bind="object" into a VNode's data.
	 */
	function bindObjectProps(data, tag, value, asProp) {
	  if (value) {
	    if (!isObject(value)) {
	      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
	    } else {
	      if (Array.isArray(value)) {
	        value = toObject(value);
	      }
	      var hash;
	      for (var key in value) {
	        if (key === 'class' || key === 'style') {
	          hash = data;
	        } else {
	          var type = data.attrs && data.attrs.type;
	          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
	        }
	        if (!(key in hash)) {
	          hash[key] = value[key];
	        }
	      }
	    }
	  }
	  return data;
	}
	
	/*  */
	
	/**
	 * Runtime helper for rendering static trees.
	 */
	function renderStatic(index, isInFor) {
	  var tree = this._staticTrees[index];
	  // if has already-rendered static tree and not inside v-for,
	  // we can reuse the same tree by doing a shallow clone.
	  if (tree && !isInFor) {
	    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
	  }
	  // otherwise, render a fresh tree.
	  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	  markStatic(tree, "__static__" + index, false);
	  return tree;
	}
	
	/**
	 * Runtime helper for v-once.
	 * Effectively it means marking the node as static with a unique key.
	 */
	function markOnce(tree, index, key) {
	  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
	  return tree;
	}
	
	function markStatic(tree, key, isOnce) {
	  if (Array.isArray(tree)) {
	    for (var i = 0; i < tree.length; i++) {
	      if (tree[i] && typeof tree[i] !== 'string') {
	        markStaticNode(tree[i], key + "_" + i, isOnce);
	      }
	    }
	  } else {
	    markStaticNode(tree, key, isOnce);
	  }
	}
	
	function markStaticNode(node, key, isOnce) {
	  node.isStatic = true;
	  node.key = key;
	  node.isOnce = isOnce;
	}
	
	/*  */
	
	function initRender(vm) {
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
	  var renderContext = parentVnode && parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
	  vm.$scopedSlots = emptyObject;
	  // bind the createElement fn to this instance
	  // so that we get proper render context inside it.
	  // args order: tag, data, children, normalizationType, alwaysNormalize
	  // internal version is used by render functions compiled from templates
	  vm._c = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, false);
	  };
	  // normalization is always applied for the public version, used in
	  // user-written render functions.
	  vm.$createElement = function (a, b, c, d) {
	    return createElement(vm, a, b, c, d, true);
	  };
	}
	
	function renderMixin(Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    return nextTick(fn, this);
	  };
	
	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;
	
	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }
	
	    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;
	
	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      handleError(e, vm, "render function");
	      // return error render result,
	      // or previous vnode to prevent render error causing blank component
	      /* istanbul ignore else */
	      if (process.env.NODE_ENV !== 'production') {
	        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
	      } else {
	        vnode = vm._vnode;
	      }
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
	        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
	      }
	      vnode = createEmptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode;
	  };
	
	  // internal render helpers.
	  // these are exposed on the instance prototype to reduce generated render
	  // code size.
	  Vue.prototype._o = markOnce;
	  Vue.prototype._n = toNumber;
	  Vue.prototype._s = toString;
	  Vue.prototype._l = renderList;
	  Vue.prototype._t = renderSlot;
	  Vue.prototype._q = looseEqual;
	  Vue.prototype._i = looseIndexOf;
	  Vue.prototype._m = renderStatic;
	  Vue.prototype._f = resolveFilter;
	  Vue.prototype._k = checkKeyCodes;
	  Vue.prototype._b = bindObjectProps;
	  Vue.prototype._v = createTextVNode;
	  Vue.prototype._e = createEmptyVNode;
	  Vue.prototype._u = resolveScopedSlots;
	}
	
	/*  */
	
	var uid = 0;
	
	function initMixin(Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid++;
	
	    var startTag, endTag;
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      startTag = "vue-perf-init:" + vm._uid;
	      endTag = "vue-perf-end:" + vm._uid;
	      mark(startTag);
	    }
	
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
	    }
	    /* istanbul ignore else */
	    if (process.env.NODE_ENV !== 'production') {
	      initProxy(vm);
	    } else {
	      vm._renderProxy = vm;
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    initRender(vm);
	    callHook(vm, 'beforeCreate');
	    initInjections(vm); // resolve injections before data/props
	    initState(vm);
	    initProvide(vm); // resolve provide after data/props
	    callHook(vm, 'created');
	
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
	      vm._name = formatComponentName(vm, false);
	      mark(endTag);
	      measure(vm._name + " init", startTag, endTag);
	    }
	
	    if (vm.$options.el) {
	      vm.$mount(vm.$options.el);
	    }
	  };
	}
	
	function initInternalComponent(vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  opts._parentElm = options._parentElm;
	  opts._refElm = options._refElm;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}
	
	function resolveConstructorOptions(Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = resolveConstructorOptions(Ctor.super);
	    var cachedSuperOptions = Ctor.superOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed,
	      // need to resolve new options.
	      Ctor.superOptions = superOptions;
	      // check if there are any late-modified/attached options (#4976)
	      var modifiedOptions = resolveModifiedOptions(Ctor);
	      // update base extend options
	      if (modifiedOptions) {
	        extend(Ctor.extendOptions, modifiedOptions);
	      }
	      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options;
	}
	
	function resolveModifiedOptions(Ctor) {
	  var modified;
	  var latest = Ctor.options;
	  var extended = Ctor.extendOptions;
	  var sealed = Ctor.sealedOptions;
	  for (var key in latest) {
	    if (latest[key] !== sealed[key]) {
	      if (!modified) {
	        modified = {};
	      }
	      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
	    }
	  }
	  return modified;
	}
	
	function dedupe(latest, extended, sealed) {
	  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
	  // between merges
	  if (Array.isArray(latest)) {
	    var res = [];
	    sealed = Array.isArray(sealed) ? sealed : [sealed];
	    extended = Array.isArray(extended) ? extended : [extended];
	    for (var i = 0; i < latest.length; i++) {
	      // push original options and not sealed options to exclude duplicated options
	      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
	        res.push(latest[i]);
	      }
	    }
	    return res;
	  } else {
	    return latest;
	  }
	}
	
	function Vue$3(options) {
	  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}
	
	initMixin(Vue$3);
	stateMixin(Vue$3);
	eventsMixin(Vue$3);
	lifecycleMixin(Vue$3);
	renderMixin(Vue$3);
	
	/*  */
	
	function initUse(Vue) {
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return this;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else if (typeof plugin === 'function') {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	}
	
	/*  */
	
	function initMixin$1(Vue) {
	  Vue.mixin = function (mixin) {
	    this.options = mergeOptions(this.options, mixin);
	    return this;
	  };
	}
	
	/*  */
	
	function initExtend(Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var SuperId = Super.cid;
	    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
	    if (cachedCtors[SuperId]) {
	      return cachedCtors[SuperId];
	    }
	
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
	      }
	    }
	
	    var Sub = function VueComponent(options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	
	    // For props and computed properties, we define the proxy getters on
	    // the Vue instances at extension time, on the extended prototype. This
	    // avoids Object.defineProperty calls for each instance created.
	    if (Sub.options.props) {
	      initProps$1(Sub);
	    }
	    if (Sub.options.computed) {
	      initComputed$1(Sub);
	    }
	
	    // allow further extension/mixin/plugin usage
	    Sub.extend = Super.extend;
	    Sub.mixin = Super.mixin;
	    Sub.use = Super.use;
	
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    ASSET_TYPES.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    Sub.sealedOptions = extend({}, Sub.options);
	
	    // cache constructor
	    cachedCtors[SuperId] = Sub;
	    return Sub;
	  };
	}
	
	function initProps$1(Comp) {
	  var props = Comp.options.props;
	  for (var key in props) {
	    proxy(Comp.prototype, "_props", key);
	  }
	}
	
	function initComputed$1(Comp) {
	  var computed = Comp.options.computed;
	  for (var key in computed) {
	    defineComputed(Comp.prototype, key, computed[key]);
	  }
	}
	
	/*  */
	
	function initAssetRegisters(Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  ASSET_TYPES.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = this.options._base.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	}
	
	/*  */
	
	var patternTypes = [String, RegExp];
	
	function getComponentName(opts) {
	  return opts && (opts.Ctor.options.name || opts.tag);
	}
	
	function matches(pattern, name) {
	  if (typeof pattern === 'string') {
	    return pattern.split(',').indexOf(name) > -1;
	  } else if (isRegExp(pattern)) {
	    return pattern.test(name);
	  }
	  /* istanbul ignore next */
	  return false;
	}
	
	function pruneCache(cache, current, filter) {
	  for (var key in cache) {
	    var cachedNode = cache[key];
	    if (cachedNode) {
	      var name = getComponentName(cachedNode.componentOptions);
	      if (name && !filter(name)) {
	        if (cachedNode !== current) {
	          pruneCacheEntry(cachedNode);
	        }
	        cache[key] = null;
	      }
	    }
	  }
	}
	
	function pruneCacheEntry(vnode) {
	  if (vnode) {
	    vnode.componentInstance.$destroy();
	  }
	}
	
	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	
	  props: {
	    include: patternTypes,
	    exclude: patternTypes
	  },
	
	  created: function created() {
	    this.cache = Object.create(null);
	  },
	
	  destroyed: function destroyed() {
	    var this$1 = this;
	
	    for (var key in this$1.cache) {
	      pruneCacheEntry(this$1.cache[key]);
	    }
	  },
	
	  watch: {
	    include: function include(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return matches(val, name);
	      });
	    },
	    exclude: function exclude(val) {
	      pruneCache(this.cache, this._vnode, function (name) {
	        return !matches(val, name);
	      });
	    }
	  },
	
	  render: function render() {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    var componentOptions = vnode && vnode.componentOptions;
	    if (componentOptions) {
	      // check pattern
	      var name = getComponentName(componentOptions);
	      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
	        return vnode;
	      }
	      var key = vnode.key == null
	      // same constructor may get registered as different local components
	      // so cid alone is not enough (#3269)
	      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
	      if (this.cache[key]) {
	        vnode.componentInstance = this.cache[key].componentInstance;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode;
	  }
	};
	
	var builtInComponents = {
	  KeepAlive: KeepAlive
	};
	
	/*  */
	
	function initGlobalAPI(Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () {
	    return config;
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    configDef.set = function () {
	      warn('Do not replace the Vue.config object, set individual fields instead.');
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	
	  // exposed util methods.
	  // NOTE: these are not considered part of the public API - avoid relying on
	  // them unless you are aware of the risk.
	  Vue.util = {
	    warn: warn,
	    extend: extend,
	    mergeOptions: mergeOptions,
	    defineReactive: defineReactive$$1
	  };
	
	  Vue.set = set;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;
	
	  Vue.options = Object.create(null);
	  ASSET_TYPES.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });
	
	  // this is used to identify the "base" constructor to extend all plain-object
	  // components with in Weex's multi-instance scenarios.
	  Vue.options._base = Vue;
	
	  extend(Vue.options.components, builtInComponents);
	
	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}
	
	initGlobalAPI(Vue$3);
	
	Object.defineProperty(Vue$3.prototype, '$isServer', {
	  get: isServerRendering
	});
	
	Object.defineProperty(Vue$3.prototype, '$ssrContext', {
	  get: function get() {
	    /* istanbul ignore next */
	    return this.$vnode.ssrContext;
	  }
	});
	
	Vue$3.version = '2.3.4';
	
	/*  */
	
	// these are reserved for web because they are directly compiled away
	// during template compilation
	var isReservedAttr = makeMap('style,class');
	
	// attributes that should be using props for binding
	var acceptValue = makeMap('input,textarea,option,select');
	var mustUseProp = function mustUseProp(tag, type, attr) {
	  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
	};
	
	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
	
	var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
	
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	
	var isXlink = function isXlink(name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
	};
	
	var getXlinkProp = function getXlinkProp(name) {
	  return isXlink(name) ? name.slice(6, name.length) : '';
	};
	
	var isFalsyAttrValue = function isFalsyAttrValue(val) {
	  return val == null || val === false;
	};
	
	/*  */
	
	function genClassForVnode(vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (isDef(childNode.componentInstance)) {
	    childNode = childNode.componentInstance._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while (isDef(parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return genClassFromData(data);
	}
	
	function mergeClassData(child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: isDef(child.class) ? [child.class, parent.class] : parent.class
	  };
	}
	
	function genClassFromData(data) {
	  var dynamicClass = data.class;
	  var staticClass = data.staticClass;
	  if (isDef(staticClass) || isDef(dynamicClass)) {
	    return concat(staticClass, stringifyClass(dynamicClass));
	  }
	  /* istanbul ignore next */
	  return '';
	}
	
	function concat(a, b) {
	  return a ? b ? a + ' ' + b : a : b || '';
	}
	
	function stringifyClass(value) {
	  if (isUndef(value)) {
	    return '';
	  }
	  if (typeof value === 'string') {
	    return value;
	  }
	  var res = '';
	  if (Array.isArray(value)) {
	    var stringified;
	    for (var i = 0, l = value.length; i < l; i++) {
	      if (isDef(value[i])) {
	        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
	          res += stringified + ' ';
	        }
	      }
	    }
	    return res.slice(0, -1);
	  }
	  if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) {
	        res += key + ' ';
	      }
	    }
	    return res.slice(0, -1);
	  }
	  /* istanbul ignore next */
	  return res;
	}
	
	/*  */
	
	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML'
	};
	
	var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');
	
	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
	
	var isReservedTag = function isReservedTag(tag) {
	  return isHTMLTag(tag) || isSVG(tag);
	};
	
	function getTagNamespace(tag) {
	  if (isSVG(tag)) {
	    return 'svg';
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math';
	  }
	}
	
	var unknownElementCache = Object.create(null);
	function isUnknownElement(tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true;
	  }
	  if (isReservedTag(tag)) {
	    return false;
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag];
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	  } else {
	    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
	  }
	}
	
	/*  */
	
	/**
	 * Query an element selector if it's not an element already.
	 */
	function query(el) {
	  if (typeof el === 'string') {
	    var selected = document.querySelector(el);
	    if (!selected) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);
	      return document.createElement('div');
	    }
	    return selected;
	  } else {
	    return el;
	  }
	}
	
	/*  */
	
	function createElement$1(tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm;
	  }
	  // false or null will remove the attribute but undefined will not
	  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm;
	}
	
	function createElementNS(namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName);
	}
	
	function createTextNode(text) {
	  return document.createTextNode(text);
	}
	
	function createComment(text) {
	  return document.createComment(text);
	}
	
	function insertBefore(parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}
	
	function removeChild(node, child) {
	  node.removeChild(child);
	}
	
	function appendChild(node, child) {
	  node.appendChild(child);
	}
	
	function parentNode(node) {
	  return node.parentNode;
	}
	
	function nextSibling(node) {
	  return node.nextSibling;
	}
	
	function tagName(node) {
	  return node.tagName;
	}
	
	function setTextContent(node, text) {
	  node.textContent = text;
	}
	
	function setAttribute(node, key, val) {
	  node.setAttribute(key, val);
	}
	
	var nodeOps = Object.freeze({
	  createElement: createElement$1,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  createComment: createComment,
	  insertBefore: insertBefore,
	  removeChild: removeChild,
	  appendChild: appendChild,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent,
	  setAttribute: setAttribute
	});
	
	/*  */
	
	var ref = {
	  create: function create(_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update(oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy(vnode) {
	    registerRef(vnode, true);
	  }
	};
	
	function registerRef(vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) {
	    return;
	  }
	
	  var vm = vnode.context;
	  var ref = vnode.componentInstance || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
	        refs[key].push(ref);
	      } else {
	        refs[key] = [ref];
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}
	
	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *
	
	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */
	
	var emptyNode = new VNode('', {}, []);
	
	var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
	
	function sameVnode(a, b) {
	  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);
	}
	
	// Some browsers do not support dynamically changing type for <input>
	// so they need to be treated as different nodes
	function sameInputType(a, b) {
	  if (a.tag !== 'input') {
	    return true;
	  }
	  var i;
	  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
	  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
	  return typeA === typeB;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) {
	      map[key] = i;
	    }
	  }
	  return map;
	}
	
	function createPatchFunction(backend) {
	  var i, j;
	  var cbs = {};
	
	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;
	
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (isDef(modules[j][hooks[i]])) {
	        cbs[hooks[i]].push(modules[j][hooks[i]]);
	      }
	    }
	  }
	
	  function emptyNodeAt(elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	  }
	
	  function createRmCb(childElm, listeners) {
	    function remove$$1() {
	      if (--remove$$1.listeners === 0) {
	        removeNode(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1;
	  }
	
	  function removeNode(el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html / v-text
	    if (isDef(parent)) {
	      nodeOps.removeChild(parent, el);
	    }
	  }
	
	  var inPre = 0;
	  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
	    vnode.isRootInsert = !nested; // for transition enter check
	    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	      return;
	    }
	
	    var data = vnode.data;
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (data && data.pre) {
	          inPre++;
	        }
	        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
	        }
	      }
	      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
	      setScope(vnode);
	
	      /* istanbul ignore if */
	      {
	        createChildren(vnode, children, insertedVnodeQueue);
	        if (isDef(data)) {
	          invokeCreateHooks(vnode, insertedVnodeQueue);
	        }
	        insert(parentElm, vnode.elm, refElm);
	      }
	
	      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
	        inPre--;
	      }
	    } else if (isTrue(vnode.isComment)) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	      insert(parentElm, vnode.elm, refElm);
	    }
	  }
	
	  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i = vnode.data;
	    if (isDef(i)) {
	      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
	      if (isDef(i = i.hook) && isDef(i = i.init)) {
	        i(vnode, false /* hydrating */, parentElm, refElm);
	      }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(vnode.componentInstance)) {
	        initComponent(vnode, insertedVnodeQueue);
	        if (isTrue(isReactivated)) {
	          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
	        }
	        return true;
	      }
	    }
	  }
	
	  function initComponent(vnode, insertedVnodeQueue) {
	    if (isDef(vnode.data.pendingInsert)) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	      vnode.data.pendingInsert = null;
	    }
	    vnode.elm = vnode.componentInstance.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }
	
	  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
	    var i;
	    // hack for #4339: a reactivated component with inner transition
	    // does not trigger because the inner node's created hooks are not called
	    // again. It's not ideal to involve module-specific logic in here but
	    // there doesn't seem to be a better way to do it.
	    var innerNode = vnode;
	    while (innerNode.componentInstance) {
	      innerNode = innerNode.componentInstance._vnode;
	      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
	        for (i = 0; i < cbs.activate.length; ++i) {
	          cbs.activate[i](emptyNode, innerNode);
	        }
	        insertedVnodeQueue.push(innerNode);
	        break;
	      }
	    }
	    // unlike a newly created component,
	    // a reactivated keep-alive component doesn't insert itself
	    insert(parentElm, vnode.elm, refElm);
	  }
	
	  function insert(parent, elm, ref) {
	    if (isDef(parent)) {
	      if (isDef(ref)) {
	        if (ref.parentNode === parent) {
	          nodeOps.insertBefore(parent, elm, ref);
	        }
	      } else {
	        nodeOps.appendChild(parent, elm);
	      }
	    }
	  }
	
	  function createChildren(vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }
	
	  function isPatchable(vnode) {
	    while (vnode.componentInstance) {
	      vnode = vnode.componentInstance._vnode;
	    }
	    return isDef(vnode.tag);
	  }
	
	  function invokeCreateHooks(vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (isDef(i.create)) {
	        i.create(emptyNode, vnode);
	      }
	      if (isDef(i.insert)) {
	        insertedVnodeQueue.push(vnode);
	      }
	    }
	  }
	
	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope(vnode) {
	    var i;
	    var ancestor = vnode;
	    while (ancestor) {
	      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
	        nodeOps.setAttribute(vnode.elm, i, '');
	      }
	      ancestor = ancestor.parent;
	    }
	    // for slot content they should also get the scopeId from the host instance.
	    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }
	
	  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
	        i(vnode);
	      }
	      for (i = 0; i < cbs.destroy.length; ++i) {
	        cbs.destroy[i](vnode);
	      }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else {
	          // Text node
	          removeNode(ch.elm);
	        }
	      }
	    }
	  }
	
	  function removeAndInvokeRemoveHook(vnode, rm) {
	    if (isDef(rm) || isDef(vnode.data)) {
	      var i;
	      var listeners = cbs.remove.length + 1;
	      if (isDef(rm)) {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      } else {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeNode(vnode.elm);
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, refElm;
	
	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) {
	        // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) {
	        // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) {
	          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) {
	          // New element
	          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
	            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
	          }
	          if (sameVnode(elmToMove, newStartVnode)) {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            // same key but different element. treat as new element
	            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return;
	    }
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
	      vnode.elm = oldVnode.elm;
	      vnode.componentInstance = oldVnode.componentInstance;
	      return;
	    }
	    var i;
	    var data = vnode.data;
	    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	    var elm = vnode.elm = oldVnode.elm;
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (isDef(data) && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) {
	        cbs.update[i](oldVnode, vnode);
	      }
	      if (isDef(i = data.hook) && isDef(i = i.update)) {
	        i(oldVnode, vnode);
	      }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) {
	          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
	        }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) {
	          nodeOps.setTextContent(elm, '');
	        }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
	        i(oldVnode, vnode);
	      }
	    }
	  }
	
	  function invokeInsertHook(vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (isTrue(initial) && isDef(vnode.parent)) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }
	
	  var bailed = false;
	  // list of modules that can skip create hook during hydration because they
	  // are already rendered on the client or has no need for initialization
	  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
	
	  // Note: this is a browser-only function so we can assume elms are DOM nodes.
	  function hydrate(elm, vnode, insertedVnodeQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false;
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) {
	        i(vnode, true /* hydrating */);
	      }
	      if (isDef(i = vnode.componentInstance)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true;
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        // empty element, allow client to pick up and populate children
	        if (!elm.hasChildNodes()) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          var childNode = elm.firstChild;
	          for (var i$1 = 0; i$1 < children.length; i$1++) {
	            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
	              childrenMatch = false;
	              break;
	            }
	            childNode = childNode.nextSibling;
	          }
	          // if childNode is not null, it means the actual childNodes list is
	          // longer than the virtual children list.
	          if (!childrenMatch || childNode) {
	            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
	            }
	            return false;
	          }
	        }
	      }
	      if (isDef(data)) {
	        for (var key in data) {
	          if (!isRenderedModule(key)) {
	            invokeCreateHooks(vnode, insertedVnodeQueue);
	            break;
	          }
	        }
	      }
	    } else if (elm.data !== vnode.text) {
	      elm.data = vnode.text;
	    }
	    return true;
	  }
	
	  function assertNodeMatch(node, vnode) {
	    if (isDef(vnode.tag)) {
	      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
	    } else {
	      return node.nodeType === (vnode.isComment ? 8 : 3);
	    }
	  }
	
	  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
	    if (isUndef(vnode)) {
	      if (isDef(oldVnode)) {
	        invokeDestroyHook(oldVnode);
	      }
	      return;
	    }
	
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];
	
	    if (isUndef(oldVnode)) {
	      // empty mount (likely as component), create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        // patch existing root node
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
	            oldVnode.removeAttribute(SSR_ATTR);
	            hydrating = true;
	          }
	          if (isTrue(hydrating)) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode;
	            } else if (process.env.NODE_ENV !== 'production') {
	              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        // replacing existing element
	        var oldElm = oldVnode.elm;
	        var parentElm$1 = nodeOps.parentNode(oldElm);
	        createElm(vnode, insertedVnodeQueue,
	        // extremely rare edge case: do not insert if old element is in a
	        // leaving transition. Only happens when combining transition +
	        // keep-alive + HOCs. (#4590)
	        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));
	
	        if (isDef(vnode.parent)) {
	          // component root element replaced.
	          // update parent placeholder node element, recursively
	          var ancestor = vnode.parent;
	          while (ancestor) {
	            ancestor.elm = vnode.elm;
	            ancestor = ancestor.parent;
	          }
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }
	
	        if (isDef(parentElm$1)) {
	          removeVnodes(parentElm$1, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }
	
	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm;
	  };
	}
	
	/*  */
	
	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives(vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};
	
	function updateDirectives(oldVnode, vnode) {
	  if (oldVnode.data.directives || vnode.data.directives) {
	    _update(oldVnode, vnode);
	  }
	}
	
	function _update(oldVnode, vnode) {
	  var isCreate = oldVnode === emptyNode;
	  var isDestroy = vnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
	
	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];
	
	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }
	
	  if (dirsWithInsert.length) {
	    var callInsert = function callInsert() {
	      for (var i = 0; i < dirsWithInsert.length; i++) {
	        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
	      }
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
	    } else {
	      callInsert();
	    }
	  }
	
	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      for (var i = 0; i < dirsWithPostpatch.length; i++) {
	        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
	      }
	    });
	  }
	
	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
	      }
	    }
	  }
	}
	
	var emptyModifiers = Object.create(null);
	
	function normalizeDirectives$1(dirs, vm) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res;
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res;
	}
	
	function getRawDirName(dir) {
	  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
	}
	
	function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    try {
	      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
	    } catch (e) {
	      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
	    }
	  }
	}
	
	var baseModules = [ref, directives];
	
	/*  */
	
	function updateAttrs(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
	    return;
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(attrs.__ob__)) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }
	
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  // #4391: in IE9, setting type can reset value for input[type=radio]
	  /* istanbul ignore if */
	  if (isIE9 && attrs.value !== oldAttrs.value) {
	    setAttr(elm, 'value', attrs.value);
	  }
	  for (key in oldAttrs) {
	    if (isUndef(attrs[key])) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}
	
	function setAttr(el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}
	
	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};
	
	/*  */
	
	function updateClass(oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
	    return;
	  }
	
	  var cls = genClassForVnode(vnode);
	
	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (isDef(transitionClass)) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }
	
	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}
	
	var klass = {
	  create: updateClass,
	  update: updateClass
	};
	
	/*  */
	
	var validDivisionCharRE = /[\w).+\-_$\]]/;
	
	function wrapFilter(exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return "_f(\"" + filter + "\")(" + exp + ")";
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return "_f(\"" + name + "\")(" + exp + "," + args;
	  }
	}
	
	/*  */
	
	/*  */
	
	/**
	 * Cross-platform code generation for component v-model
	 */
	
	/**
	 * Cross-platform codegen helper for generating v-model value assignment code.
	 */
	
	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */
	
	var str;
	var index$1;
	
	/*  */
	
	// in some cases, the event used has to be determined at runtime
	// so we used some reserved tokens during compile.
	var RANGE_TOKEN = '__r';
	var CHECKBOX_RADIO_TOKEN = '__c';
	
	/*  */
	
	// normalize v-model event tokens that can only be determined at runtime.
	// it's important to place the event as the first in the array because
	// the whole point is ensuring the v-model callback gets called before
	// user-attached handlers.
	function normalizeEvents(on) {
	  var event;
	  /* istanbul ignore if */
	  if (isDef(on[RANGE_TOKEN])) {
	    // IE input[type=range] only supports `change` event
	    event = isIE ? 'change' : 'input';
	    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
	    delete on[RANGE_TOKEN];
	  }
	  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
	    // Chrome fires microtasks in between click/change, leads to #4521
	    event = isChrome ? 'click' : 'change';
	    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
	    delete on[CHECKBOX_RADIO_TOKEN];
	  }
	}
	
	var target$1;
	
	function add$1(event, _handler, once$$1, capture, passive) {
	  if (once$$1) {
	    var oldHandler = _handler;
	    var _target = target$1; // save current target element in closure
	    _handler = function handler(ev) {
	      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
	      if (res !== null) {
	        remove$2(event, _handler, capture, _target);
	      }
	    };
	  }
	  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
	}
	
	function remove$2(event, handler, capture, _target) {
	  (_target || target$1).removeEventListener(event, handler, capture);
	}
	
	function updateDOMListeners(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
	    return;
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  target$1 = vnode.elm;
	  normalizeEvents(on);
	  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
	}
	
	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};
	
	/*  */
	
	function updateDOMProps(oldVnode, vnode) {
	  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
	    return;
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (isDef(props.__ob__)) {
	    props = vnode.data.domProps = extend({}, props);
	  }
	
	  for (key in oldProps) {
	    if (isUndef(props[key])) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if (key === 'textContent' || key === 'innerHTML') {
	      if (vnode.children) {
	        vnode.children.length = 0;
	      }
	      if (cur === oldProps[key]) {
	        continue;
	      }
	    }
	
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = isUndef(cur) ? '' : String(cur);
	      if (shouldUpdateValue(elm, vnode, strCur)) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}
	
	// check platforms/web/util/attrs.js acceptValue
	
	
	function shouldUpdateValue(elm, vnode, checkVal) {
	  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
	}
	
	function isDirty(elm, checkVal) {
	  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
	  return document.activeElement !== elm && elm.value !== checkVal;
	}
	
	function isInputChanged(elm, newVal) {
	  var value = elm.value;
	  var modifiers = elm._vModifiers; // injected by v-model runtime
	  if (isDef(modifiers) && modifiers.number || elm.type === 'number') {
	    return toNumber(value) !== toNumber(newVal);
	  }
	  if (isDef(modifiers) && modifiers.trim) {
	    return value.trim() !== newVal.trim();
	  }
	  return value !== newVal;
	}
	
	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};
	
	/*  */
	
	var parseStyleText = cached(function (cssText) {
	  var res = {};
	  var listDelimiter = /;(?![^(]*\))/g;
	  var propertyDelimiter = /:(.+)/;
	  cssText.split(listDelimiter).forEach(function (item) {
	    if (item) {
	      var tmp = item.split(propertyDelimiter);
	      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
	    }
	  });
	  return res;
	});
	
	// merge static and dynamic style data on the same vnode
	function normalizeStyleData(data) {
	  var style = normalizeStyleBinding(data.style);
	  // static style is pre-processed into an object during compilation
	  // and is always a fresh object, so it's safe to merge into it
	  return data.staticStyle ? extend(data.staticStyle, style) : style;
	}
	
	// normalize possible array / string values into Object
	function normalizeStyleBinding(bindingStyle) {
	  if (Array.isArray(bindingStyle)) {
	    return toObject(bindingStyle);
	  }
	  if (typeof bindingStyle === 'string') {
	    return parseStyleText(bindingStyle);
	  }
	  return bindingStyle;
	}
	
	/**
	 * parent component style should be after child's
	 * so that parent component's style could override it
	 */
	function getStyle(vnode, checkChild) {
	  var res = {};
	  var styleData;
	
	  if (checkChild) {
	    var childNode = vnode;
	    while (childNode.componentInstance) {
	      childNode = childNode.componentInstance._vnode;
	      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
	        extend(res, styleData);
	      }
	    }
	  }
	
	  if (styleData = normalizeStyleData(vnode.data)) {
	    extend(res, styleData);
	  }
	
	  var parentNode = vnode;
	  while (parentNode = parentNode.parent) {
	    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
	      extend(res, styleData);
	    }
	  }
	  return res;
	}
	
	/*  */
	
	var cssVarRE = /^--/;
	var importantRE = /\s*!important$/;
	var setProp = function setProp(el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else if (importantRE.test(val)) {
	    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
	  } else {
	    var normalizedName = normalize(name);
	    if (Array.isArray(val)) {
	      // Support values array created by autoprefixer, e.g.
	      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
	      // Set them one by one, and the browser will only set those it can recognize
	      for (var i = 0, len = val.length; i < len; i++) {
	        el.style[normalizedName] = val[i];
	      }
	    } else {
	      el.style[normalizedName] = val;
	    }
	  }
	};
	
	var prefixes = ['Webkit', 'Moz', 'ms'];
	
	var testEl;
	var normalize = cached(function (prop) {
	  testEl = testEl || document.createElement('div');
	  prop = camelize(prop);
	  if (prop !== 'filter' && prop in testEl.style) {
	    return prop;
	  }
	  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefixed = prefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return prefixed;
	    }
	  }
	});
	
	function updateStyle(oldVnode, vnode) {
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	
	  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
	    return;
	  }
	
	  var cur, name;
	  var el = vnode.elm;
	  var oldStaticStyle = oldData.staticStyle;
	  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
	
	  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
	  var oldStyle = oldStaticStyle || oldStyleBinding;
	
	  var style = normalizeStyleBinding(vnode.data.style) || {};
	
	  // store normalized style under a different key for next diff
	  // make sure to clone it if it's reactive, since the user likley wants
	  // to mutate it.
	  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
	
	  var newStyle = getStyle(vnode, true);
	
	  for (name in oldStyle) {
	    if (isUndef(newStyle[name])) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in newStyle) {
	    cur = newStyle[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}
	
	var style = {
	  create: updateStyle,
	  update: updateStyle
	};
	
	/*  */
	
	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.add(c);
	      });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass(el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !(cls = cls.trim())) {
	    return;
	  }
	
	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) {
	        return el.classList.remove(c);
	      });
	    } else {
	      el.classList.remove(cls);
	    }
	  } else {
	    var cur = " " + (el.getAttribute('class') || '') + " ";
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    el.setAttribute('class', cur.trim());
	  }
	}
	
	/*  */
	
	function resolveTransition(def$$1) {
	  if (!def$$1) {
	    return;
	  }
	  /* istanbul ignore else */
	  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res;
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1);
	  }
	}
	
	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: name + "-enter",
	    enterToClass: name + "-enter-to",
	    enterActiveClass: name + "-enter-active",
	    leaveClass: name + "-leave",
	    leaveToClass: name + "-leave-to",
	    leaveActiveClass: name + "-leave-active"
	  };
	});
	
	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';
	
	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}
	
	// binding to window is necessary to make hot reload work in IE in strict mode
	var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;
	
	function nextFrame(fn) {
	  raf(function () {
	    raf(fn);
	  });
	}
	
	function addTransitionClass(el, cls) {
	  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
	  addClass(el, cls);
	}
	
	function removeTransitionClass(el, cls) {
	  if (el._transitionClasses) {
	    remove(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}
	
	function whenTransitionEnds(el, expectedType, cb) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) {
	    return cb();
	  }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function end() {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function onEnd(e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}
	
	var transformRE = /\b(transform|all)(,|$)/;
	
	function getTransitionInfo(el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);
	
	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
	    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
	  }
	  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  };
	}
	
	function getTimeout(delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }
	
	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i]);
	  }));
	}
	
	function toMs(s) {
	  return Number(s.slice(0, -1)) * 1000;
	}
	
	/*  */
	
	function enter(vnode, toggleDisplay) {
	  var el = vnode.elm;
	
	  // call leave callback now
	  if (isDef(el._leaveCb)) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return;
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._enterCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterToClass = data.enterToClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearToClass = data.appearToClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;
	  var duration = data.duration;
	
	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var context = activeInstance;
	  var transitionNode = activeInstance.$vnode;
	  while (transitionNode && transitionNode.parent) {
	    transitionNode = transitionNode.parent;
	    context = transitionNode.context;
	  }
	
	  var isAppear = !context._isMounted || !vnode.isRootInsert;
	
	  if (isAppear && !appear && appear !== '') {
	    return;
	  }
	
	  var startClass = isAppear && appearClass ? appearClass : enterClass;
	  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
	  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
	
	  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
	  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
	  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
	  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
	
	  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
	
	  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
	    checkDuration(explicitEnterDuration, 'enter', vnode);
	  }
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(enterHook);
	
	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, toClass);
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });
	
	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    });
	  }
	
	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      addTransitionClass(el, toClass);
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        if (isValidDuration(explicitEnterDuration)) {
	          setTimeout(cb, explicitEnterDuration);
	        } else {
	          whenTransitionEnds(el, type, cb);
	        }
	      }
	    });
	  }
	
	  if (vnode.data.show) {
	    toggleDisplay && toggleDisplay();
	    enterHook && enterHook(el, cb);
	  }
	
	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}
	
	function leave(vnode, rm) {
	  var el = vnode.elm;
	
	  // call enter callback now
	  if (isDef(el._enterCb)) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }
	
	  var data = resolveTransition(vnode.data.transition);
	  if (isUndef(data)) {
	    return rm();
	  }
	
	  /* istanbul ignore if */
	  if (isDef(el._leaveCb) || el.nodeType !== 1) {
	    return;
	  }
	
	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveToClass = data.leaveToClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;
	  var duration = data.duration;
	
	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl = getHookArgumentsLength(leave);
	
	  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
	
	  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
	    checkDuration(explicitLeaveDuration, 'leave', vnode);
	  }
	
	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveToClass);
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });
	
	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }
	
	  function performLeave() {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return;
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        addTransitionClass(el, leaveToClass);
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          if (isValidDuration(explicitLeaveDuration)) {
	            setTimeout(cb, explicitLeaveDuration);
	          } else {
	            whenTransitionEnds(el, type, cb);
	          }
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}
	
	// only used in dev mode
	function checkDuration(val, name, vnode) {
	  if (typeof val !== 'number') {
	    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
	  } else if (isNaN(val)) {
	    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
	  }
	}
	
	function isValidDuration(val) {
	  return typeof val === 'number' && !isNaN(val);
	}
	
	/**
	 * Normalize a transition hook's argument length. The hook may be:
	 * - a merged hook (invoker) with the original in .fns
	 * - a wrapped component method (check ._length)
	 * - a plain function (.length)
	 */
	function getHookArgumentsLength(fn) {
	  if (isUndef(fn)) {
	    return false;
	  }
	  var invokerFns = fn.fns;
	  if (isDef(invokerFns)) {
	    // invoker
	    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
	  } else {
	    return (fn._length || fn.length) > 1;
	  }
	}
	
	function _enter(_, vnode) {
	  if (vnode.data.show !== true) {
	    enter(vnode);
	  }
	}
	
	var transition = inBrowser ? {
	  create: _enter,
	  activate: _enter,
	  remove: function remove$$1(vnode, rm) {
	    /* istanbul ignore else */
	    if (vnode.data.show !== true) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};
	
	var platformModules = [attrs, klass, events, domProps, style, transition];
	
	/*  */
	
	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);
	
	var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
	
	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */
	
	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}
	
	var model$1 = {
	  inserted: function inserted(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      var cb = function cb() {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {
	      el._vModifiers = binding.modifiers;
	      if (!binding.modifiers.lazy) {
	        // Safari < 10.2 & UIWebView doesn't fire compositionend when
	        // switching focus before confirming composition choice
	        // this also fixes the issue where some browsers e.g. iOS Chrome
	        // fires "change" instead of "input" on autocomplete.
	        el.addEventListener('change', onCompositionEnd);
	        if (!isAndroid) {
	          el.addEventListener('compositionstart', onCompositionStart);
	          el.addEventListener('compositionend', onCompositionEnd);
	        }
	        /* istanbul ignore if */
	        if (isIE9) {
	          el.vmodel = true;
	        }
	      }
	    }
	  },
	  componentUpdated: function componentUpdated(el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var needReset = el.multiple ? binding.value.some(function (v) {
	        return hasNoMatchingOption(v, el.options);
	      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
	      if (needReset) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};
	
	function setSelected(el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    process.env.NODE_ENV !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
	    return;
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return;
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}
	
	function hasNoMatchingOption(value, options) {
	  for (var i = 0, l = options.length; i < l; i++) {
	    if (looseEqual(getValue(options[i]), value)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	function getValue(option) {
	  return '_value' in option ? option._value : option.value;
	}
	
	function onCompositionStart(e) {
	  e.target.composing = true;
	}
	
	function onCompositionEnd(e) {
	  // prevent triggering an input event for no reason
	  if (!e.target.composing) {
	    return;
	  }
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}
	
	function trigger(el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}
	
	/*  */
	
	// recursively search for possible transition defined inside the component root
	function locateNode(vnode) {
	  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
	}
	
	var show = {
	  bind: function bind(el, ref, vnode) {
	    var value = ref.value;
	
	    vnode = locateNode(vnode);
	    var transition = vnode.data && vnode.data.transition;
	    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
	    if (value && transition && !isIE9) {
	      vnode.data.show = true;
	      enter(vnode, function () {
	        el.style.display = originalDisplay;
	      });
	    } else {
	      el.style.display = value ? originalDisplay : 'none';
	    }
	  },
	
	  update: function update(el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;
	
	    /* istanbul ignore if */
	    if (value === oldValue) {
	      return;
	    }
	    vnode = locateNode(vnode);
	    var transition = vnode.data && vnode.data.transition;
	    if (transition && !isIE9) {
	      vnode.data.show = true;
	      if (value) {
	        enter(vnode, function () {
	          el.style.display = el.__vOriginalDisplay;
	        });
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  },
	
	  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
	    if (!isDestroy) {
	      el.style.display = el.__vOriginalDisplay;
	    }
	  }
	};
	
	var platformDirectives = {
	  model: model$1,
	  show: show
	};
	
	/*  */
	
	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)
	
	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterToClass: String,
	  leaveToClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  duration: [Number, String, Object]
	};
	
	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild(vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children));
	  } else {
	    return vnode;
	  }
	}
	
	function extractTransitionData(comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1];
	  }
	  return data;
	}
	
	function placeholder(h, rawChild) {
	  if (/\d-keep-alive$/.test(rawChild.tag)) {
	    return h('keep-alive', {
	      props: rawChild.componentOptions.propsData
	    });
	  }
	}
	
	function hasParentTransition(vnode) {
	  while (vnode = vnode.parent) {
	    if (vnode.data.transition) {
	      return true;
	    }
	  }
	}
	
	function isSameChild(child, oldChild) {
	  return oldChild.key === child.key && oldChild.tag === child.tag;
	}
	
	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	
	  render: function render(h) {
	    var this$1 = this;
	
	    var children = this.$slots.default;
	    if (!children) {
	      return;
	    }
	
	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) {
	      return c.tag;
	    });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return;
	    }
	
	    // warn multiple elements
	    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
	      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
	    }
	
	    var mode = this.mode;
	
	    // warn invalid mode
	    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn('invalid <transition> mode: ' + mode, this.$parent);
	    }
	
	    var rawChild = children[0];
	
	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild;
	    }
	
	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild;
	    }
	
	    if (this._leaving) {
	      return placeholder(h, rawChild);
	    }
	
	    // ensure a key that is unique to the vnode type and to this transition
	    // component instance. This key will be used to remove pending leaving nodes
	    // during entering.
	    var id = "__transition-" + this._uid + "-";
	    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
	
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);
	
	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) {
	      return d.name === 'show';
	    })) {
	      child.data.show = true;
	    }
	
	    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        });
	        return placeholder(h, rawChild);
	      } else if (mode === 'in-out') {
	        var delayedLeave;
	        var performLeave = function performLeave() {
	          delayedLeave();
	        };
	        mergeVNodeHook(data, 'afterEnter', performLeave);
	        mergeVNodeHook(data, 'enterCancelled', performLeave);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        });
	      }
	    }
	
	    return rawChild;
	  }
	};
	
	/*  */
	
	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.
	
	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final desired state. This way in the second pass removed
	// nodes will remain where they should be.
	
	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);
	
	delete props.mode;
	
	var TransitionGroup = {
	  props: props,
	
	  render: function render(h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);
	
	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
	        } else if (process.env.NODE_ENV !== 'production') {
	          var opts = c.componentOptions;
	          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
	          warn("<transition-group> children must be keyed: <" + name + ">");
	        }
	      }
	    }
	
	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }
	
	    return h(tag, null, children);
	  },
	
	  beforeUpdate: function beforeUpdate() {
	    // force removing pass
	    this.__patch__(this._vnode, this.kept, false, // hydrating
	    true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },
	
	  updated: function updated() {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || (this.name || 'v') + '-move';
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return;
	    }
	
	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);
	
	    // force reflow to put everything in position
	    var body = document.body;
	    var f = body.offsetHeight; // eslint-disable-line
	
	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },
	
	  methods: {
	    hasMove: function hasMove(el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false;
	      }
	      if (this._hasMove != null) {
	        return this._hasMove;
	      }
	      // Detect whether an element with the move class applied has
	      // CSS transitions. Since the element may be inside an entering
	      // transition at this very moment, we make a clone of it and remove
	      // all other transition classes applied to ensure only the move class
	      // is applied.
	      var clone = el.cloneNode();
	      if (el._transitionClasses) {
	        el._transitionClasses.forEach(function (cls) {
	          removeClass(clone, cls);
	        });
	      }
	      addClass(clone, moveClass);
	      clone.style.display = 'none';
	      this.$el.appendChild(clone);
	      var info = getTransitionInfo(clone);
	      this.$el.removeChild(clone);
	      return this._hasMove = info.hasTransform;
	    }
	  }
	};
	
	function callPendingCbs(c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}
	
	function recordPosition(c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}
	
	function applyTranslation(c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}
	
	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};
	
	/*  */
	
	// install platform specific utils
	Vue$3.config.mustUseProp = mustUseProp;
	Vue$3.config.isReservedTag = isReservedTag;
	Vue$3.config.isReservedAttr = isReservedAttr;
	Vue$3.config.getTagNamespace = getTagNamespace;
	Vue$3.config.isUnknownElement = isUnknownElement;
	
	// install platform runtime directives & components
	extend(Vue$3.options.directives, platformDirectives);
	extend(Vue$3.options.components, platformComponents);
	
	// install platform patch function
	Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
	
	// public mount method
	Vue$3.prototype.$mount = function (el, hydrating) {
	  el = el && inBrowser ? query(el) : undefined;
	  return mountComponent(this, el, hydrating);
	};
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$3);
	    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
	      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
	    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
	  }
	}, 0);
	
	/*  */
	
	module.exports = Vue$3;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(300), (function() { return this; }())))

/***/ }),
/* 300 */
/***/ (function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) {
	    return [];
	};
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ }),
/* 301 */,
/* 302 */
/***/ (function(module, exports) {

	/* globals __VUE_SSR_CONTEXT__ */
	
	// this module is a runtime utility for cleaner component module output and will
	// be included in the final webpack user bundle
	
	module.exports = function normalizeComponent (
	  rawScriptExports,
	  compiledTemplate,
	  injectStyles,
	  scopeId,
	  moduleIdentifier /* server only */
	) {
	  var esModule
	  var scriptExports = rawScriptExports = rawScriptExports || {}
	
	  // ES6 modules interop
	  var type = typeof rawScriptExports.default
	  if (type === 'object' || type === 'function') {
	    esModule = rawScriptExports
	    scriptExports = rawScriptExports.default
	  }
	
	  // Vue.extend constructor export interop
	  var options = typeof scriptExports === 'function'
	    ? scriptExports.options
	    : scriptExports
	
	  // render functions
	  if (compiledTemplate) {
	    options.render = compiledTemplate.render
	    options.staticRenderFns = compiledTemplate.staticRenderFns
	  }
	
	  // scopedId
	  if (scopeId) {
	    options._scopeId = scopeId
	  }
	
	  var hook
	  if (moduleIdentifier) { // server build
	    hook = function (context) {
	      // 2.3 injection
	      context =
	        context || // cached call
	        (this.$vnode && this.$vnode.ssrContext) || // stateful
	        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
	      // 2.2 with runInNewContext: true
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__
	      }
	      // inject component styles
	      if (injectStyles) {
	        injectStyles.call(this, context)
	      }
	      // register component module identifier for async chunk inferrence
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier)
	      }
	    }
	    // used by ssr in case component is cached and beforeCreate
	    // never gets called
	    options._ssrRegister = hook
	  } else if (injectStyles) {
	    hook = injectStyles
	  }
	
	  if (hook) {
	    var functional = options.functional
	    var existing = functional
	      ? options.render
	      : options.beforeCreate
	    if (!functional) {
	      // inject component registration as beforeCreate hook
	      options.beforeCreate = existing
	        ? [].concat(existing, hook)
	        : [hook]
	    } else {
	      // register for functioal component in vue file
	      options.render = function renderWithStyleInjection (h, context) {
	        hook.call(context)
	        return existing(h, context)
	      }
	    }
	  }
	
	  return {
	    esModule: esModule,
	    exports: scriptExports,
	    options: options
	  }
	}


/***/ }),
/* 303 */,
/* 304 */,
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(2);
	
	var _vue = __webpack_require__(299);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _tab = __webpack_require__(306);
	
	var _tab2 = _interopRequireDefault(_tab);
	
	var _vueAsyncComputed = __webpack_require__(309);
	
	var _vueAsyncComputed2 = _interopRequireDefault(_vueAsyncComputed);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable no-unused-vars */
	
	_vue2.default.use(_vueAsyncComputed2.default);
	
	var app = new _vue2.default({
	  el: '#app',
	  render: function render(h) {
	    return h(
	      _tab2.default,
	      null,
	      []
	    );
	  }
	});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	var disposed = false
	var Component = __webpack_require__(302)(
	  /* script */
	  __webpack_require__(307),
	  /* template */
	  __webpack_require__(308),
	  /* styles */
	  null,
	  /* scopeId */
	  null,
	  /* moduleIdentifier (server only) */
	  null
	)
	Component.options.__file = "/Users/rachel-killackey/Desktop/LaunchPad/internal/fotofluent/app/components/tab.vue"
	if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
	if (Component.options.functional) {console.error("[vue-loader] tab.vue: functional components are not supported with templates, they should use render functions.")}
	
	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-8fdb3c0a", Component.options)
	  } else {
	    hotAPI.reload("data-v-8fdb3c0a", Component.options)
	  }
	  module.hot.dispose(function (data) {
	    disposed = true
	  })
	})()}
	
	module.exports = Component.exports


/***/ }),
/* 307 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	//
	//
	//
	//
	
	exports.default = {
	  // name: 'tab'
	};

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('p', [_vm._v("Hello!")])
	},staticRenderFns: []}
	module.exports.render._withStripped = true
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-hot-reload-api").rerender("data-v-8fdb3c0a", module.exports)
	  }
	}

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	(function (global, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined") {
	    factory(module, exports);
	  } else {
	    var mod = {
	      exports: {}
	    };
	    factory(mod, mod.exports);
	    global.AsyncComputed = mod.exports;
	  }
	})(undefined, function (module, exports) {
	  'use strict';
	
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var prefix = '_async_computed$';
	
	  var AsyncComputed = {
	    install: function install(Vue, pluginOptions) {
	      pluginOptions = pluginOptions || {};
	
	      Vue.config.optionMergeStrategies.asyncComputed = Vue.config.optionMergeStrategies.computed;
	
	      Vue.mixin({
	        beforeCreate: function beforeCreate() {
	          var optionData = this.$options.data;
	
	          if (!this.$options.computed) this.$options.computed = {};
	
	          for (var key in this.$options.asyncComputed || {}) {
	            this.$options.computed[prefix + key] = getterFor(this.$options.asyncComputed[key]);
	          }
	
	          this.$options.data = function vueAsyncComputedInjectedDataFn() {
	            var data = (typeof optionData === 'function' ? optionData.call(this) : optionData) || {};
	            for (var _key in this.$options.asyncComputed || {}) {
	              data[_key] = null;
	            }
	            return data;
	          };
	        },
	        created: function created() {
	          var _this = this;
	
	          for (var key in this.$options.asyncComputed || {}) {
	            this[key] = defaultFor.call(this, this.$options.asyncComputed[key], pluginOptions);
	          }
	
	          var _loop = function _loop(_key2) {
	            var promiseId = 0;
	            _this.$watch(prefix + _key2, function (newPromise) {
	              var thisPromise = ++promiseId;
	
	              if (!newPromise || !newPromise.then) {
	                newPromise = Promise.resolve(newPromise);
	              }
	
	              newPromise.then(function (value) {
	                if (thisPromise !== promiseId) return;
	                _this[_key2] = value;
	              }).catch(function (err) {
	                if (thisPromise !== promiseId) return;
	
	                if (pluginOptions.errorHandler === false) return;
	
	                var handler = pluginOptions.errorHandler === undefined ? console.error.bind(console, 'Error evaluating async computed property:') : pluginOptions.errorHandler;
	
	                if (pluginOptions.useRawError) {
	                  handler(err);
	                } else {
	                  handler(err.stack);
	                }
	              });
	            }, { immediate: true });
	          };
	
	          for (var _key2 in this.$options.asyncComputed || {}) {
	            _loop(_key2);
	          }
	        }
	      });
	    }
	  };
	
	  function getterFor(fn) {
	    if (typeof fn === 'function') return fn;
	
	    var getter = fn.get;
	
	    if (fn.hasOwnProperty('watch')) {
	      getter = function getter() {
	        fn.watch.call(this);
	        return fn.get.call(this);
	      };
	    }
	    return getter;
	  }
	
	  function defaultFor(fn, pluginOptions) {
	    var defaultValue = null;
	
	    if ('default' in fn) {
	      defaultValue = fn.default;
	    } else if ('default' in pluginOptions) {
	      defaultValue = pluginOptions.default;
	    }
	
	    if (typeof defaultValue === 'function') {
	      return defaultValue.call(this);
	    } else {
	      return defaultValue;
	    }
	  }
	
	  exports.default = AsyncComputed;
	
	  /* istanbul ignore if */
	  if (typeof window !== 'undefined' && window.Vue) {
	    // Auto install in dist mode
	    window.Vue.use(AsyncComputed);
	  }
	  module.exports = exports['default'];
	});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMGQxYzY2ZGE5MzY5NWQyMTMyYmM/ZjljYyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcz8zNzE3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9zaGltLmpzPzcyNmYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcz9hNjU3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanM/ZDQyOSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzPzc0MTciLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzPzgyYmEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzPzJmM2YiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcz8zODcwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzP2EwMzIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanM/NzE3MSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzP2M0MjYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcz9hMGI2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanM/NmVmMiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanM/ZGU2MyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcz9iMDNkIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanM/ZDYyYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcz83NjZiIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcz8yMTNlIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanM/Mzc4NyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzPzIzNzkiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanM/NWMxNiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcz9kM2NjIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanM/YWI4ZCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanM/YzAyZCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzPzJlOWMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanM/OWY1YiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcz84ODM0Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzPzFiOWMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzPzk0NjUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzPzIwMjgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzPzExYjgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanM/NzJmZCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcz85NTIxIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanM/MTFiYiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcz80MjllIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz83OWVmIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/ZjA4MCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcz8yYTUzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcz9jMzE3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzPzE5NWUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanM/MTQ4MiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzPzgzMGIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzPzMyYzAiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanM/NzljZiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanM/NmMwMiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcz84Yjg3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzP2NiYWIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanM/MWZkNiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzP2NjMjciLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzPzk1NzYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzPzlhN2UiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanM/YjMxNSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcz8wN2I3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanM/NTc0NiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcz9mYWI2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzP2U4MWEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzPzliOGYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcz8wYzczIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzPzFkNTYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzPzY5NWYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzPzk4YzUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanM/NDY4ZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanM/MDViNCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcz9iN2U2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzP2RhYWEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanM/NmY1NCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanM/ZWQ4MSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcz9iMWJlIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzPzUyMzMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcz9hZjczIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzPzQ3ZGEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzP2M1NWUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcz8yNzhkIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzPzQxNTYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanM/NjRjZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcz85MWNiIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzP2QzOWEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcz8yYjQ1Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzPzlkNzEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcz80OGU3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanM/YTRlYiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzPzE4ODEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzP2YzYjAiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcz8yM2MwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcz82MjYwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcz81MmZhIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanM/MzliOCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcz83NTllIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanM/NzdmYiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanM/N2U5NyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcz82YzU2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzPzkwODUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzPzZlZDEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanM/NDcxZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanM/ZGY3OCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcz81YzQ0Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzPzQxODMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanM/ZTdiZiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanM/NmI1NyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanM/NzgxMSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzPzY0YzEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanM/MGUwYiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcz83Mzk2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzP2FkYzMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanM/ODZmYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcz8xODNiIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanM/NDliMCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzPzQyNGQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanM/MjNhMyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzPzMwOTAiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanM/N2NjYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcz82NzM3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcz9iN2M0Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzPzlmZGUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcz81MzM2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzP2RiZTEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanM/YTgwNSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzP2YzMDUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcz9lOWU4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanM/NGU0NiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzPzcxNjQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanM/NmUxNCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcz8wYjMxIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzP2JkZDgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzPzRiZTEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcz8yM2U4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanM/N2U1ZCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanM/NGVlMyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzP2EyMzEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzPzliNjgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzP2M3OWQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanM/NjNkZiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanM/MjhlMiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzP2E0YjgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcz83YThhIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanM/OTVmNSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcz81MGYzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanM/NjcyZiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcz84Y2ExIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcz81ZTljIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzP2ViMzIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcz8yZGZmIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcz9jZWU4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanM/MDQxYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcz85N2Q0Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanM/MmNlYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanM/Y2NkYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanM/MjlmNiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzP2NkNDAiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanM/MWI4MCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcz8wNGViIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzP2E3ZmQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzP2Q0YjIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcz9jMzkwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanM/Zjk3YyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanM/NTRkNyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanM/YmI3OSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanM/NWRiOSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanM/OTVkMyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcz9jNTg2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanM/ZTI3ZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcz8zMzkwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanM/ZGVjZCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanM/NjkzYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanM/MTVkYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanM/ZTg3NCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcz82ZWVjIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzPzE5MjMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzPzYzODEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanM/YWU3MiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanM/NGQ5MCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcz8zYzIwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcz9hN2VlIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzPzhhMWUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcz9lMDVmIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanM/ZGNiNSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcz8wMmZhIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcz9lYjZiIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanM/NGY0NSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzP2FhMGUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcz9hZjQyIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcz85OWE3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzPzA4ODkiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzP2ZlNzEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzP2QyYWEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcz9mMmY0Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzP2M3OTUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanM/ZmViYiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcz8wZDY4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzPzdmNjgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanM/MDA3NSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanM/YjM3MiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanM/NzA4YiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzPzAwMzgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcz8wZDNjIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcz9lNTY4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzP2MxOTgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcz84M2I0Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanM/ODBjMCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcz8wNjQ3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcz9kZDE5Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzP2FmZjYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcz80YTAyIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzP2JjMDEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzP2M3ODciLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcz8wNzViIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzPzA4ZmMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanM/MzZmYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzP2Q5MDEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcz84MDY1Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanM/ZmNjMCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanM/ZDEwMCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcz82MzE4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanM/OThiNSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanM/Mjc1NiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzPzk1MmIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzPzc3OWUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcz8yNGFkIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcz9jMjZhIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanM/MTI4ZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzPzA1ZDUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanM/NjM2MSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanM/ZDZjNyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanM/ZGQzYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcz9lYmExIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcz8yOTI4Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanM/MjMzMiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanM/NTYyNyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzPzgyZWYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanM/ZThkNCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcz8yNDAwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzPzE5NzAiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzP2EwMDUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzP2MyOTYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzPzUxZDIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzPzU0ZWEiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzPzJkMGUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzc0MTUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcz80ODUwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcz9lZDIxIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanM/ZDgwMyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcz81ZmZmIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcz83ZjRmIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcz81NTg1Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcz82ZTE5Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanM/NjI1ZCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanM/YjlhYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzP2U0ZTgiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanM/NzE1MyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcz9iMmI1Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcz9lMWI1Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzPzE4MzYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzPzU0MWQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanM/M2RlZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzP2YwYTkiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzP2Q2ZjYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzP2E3NzAiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanM/NWQ3MiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzPzdkOTkiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzPzU1YTkiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzPzFiMTIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzPzgwNTUiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzPzkyNmYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzPzNkZTIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzPzM1MjYiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzPzAyMDMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcz9hZmMyIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzP2NlOGQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzPzA4OGIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanM/MDVmYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanM/MWQ5MCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcz8wNDU3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzPzQyZDMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanM/YzQ4MyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcz8wYzRmIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcz82OWIxIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcz82ZGVkIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcz8yMjE2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcz8yZTA2Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzP2YyNDQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcz9hZTU3Iiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcz8xMGNjIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcz80ZWEyIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanM/NWQ0ZSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcz8wYzcwIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzPzQzMzQiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanM/ODZhYSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzPzAyMmIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanM/ODFlYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcz9jMTJjIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanM/ZjkzYyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzPzY3NWMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/MWFhYiIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanM/Y2NkNSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanM/ZjY0NCIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanM/YWY5NyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmNvbW1vbi5qcz9kNDNmIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcz9kNGYzIiwid2VicGFjazovLy8uL2FwcC9zY3JpcHRzL3RhYi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy90YWIudnVlIiwid2VicGFjazovLy90YWIudnVlIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL3RhYi52dWU/MjhiMiIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1hc3luYy1jb21wdXRlZC9kaXN0L2luZGV4LmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJnbG9iYWwiLCJfYmFiZWxQb2x5ZmlsbCIsIkVycm9yIiwiREVGSU5FX1BST1BFUlRZIiwiZGVmaW5lIiwiTyIsImtleSIsInZhbHVlIiwiT2JqZWN0Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJwYWRTdGFydCIsInBhZEVuZCIsInNwbGl0IiwiZm9yRWFjaCIsIkFycmF5IiwiRnVuY3Rpb24iLCJjYWxsIiwiYmluZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJoYXMiLCJERVNDUklQVE9SUyIsIiRleHBvcnQiLCJyZWRlZmluZSIsIk1FVEEiLCJLRVkiLCIkZmFpbHMiLCJzaGFyZWQiLCJzZXRUb1N0cmluZ1RhZyIsInVpZCIsIndrcyIsIndrc0V4dCIsIndrc0RlZmluZSIsImtleU9mIiwiZW51bUtleXMiLCJpc0FycmF5IiwiYW5PYmplY3QiLCJ0b0lPYmplY3QiLCJ0b1ByaW1pdGl2ZSIsImNyZWF0ZURlc2MiLCJfY3JlYXRlIiwiZ09QTkV4dCIsIiRHT1BEIiwiJERQIiwiJGtleXMiLCJnT1BEIiwiZiIsImRQIiwiZ09QTiIsIiRTeW1ib2wiLCJTeW1ib2wiLCIkSlNPTiIsIkpTT04iLCJfc3RyaW5naWZ5Iiwic3RyaW5naWZ5IiwiUFJPVE9UWVBFIiwiSElEREVOIiwiVE9fUFJJTUlUSVZFIiwiaXNFbnVtIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJTeW1ib2xSZWdpc3RyeSIsIkFsbFN5bWJvbHMiLCJPUFN5bWJvbHMiLCJPYmplY3RQcm90byIsIlVTRV9OQVRJVkUiLCJRT2JqZWN0Iiwic2V0dGVyIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzYyIsImdldCIsImEiLCJpdCIsIkQiLCJwcm90b0Rlc2MiLCJ3cmFwIiwidGFnIiwic3ltIiwiX2siLCJpc1N5bWJvbCIsIml0ZXJhdG9yIiwiJGRlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiJGRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiUCIsImtleXMiLCJpIiwibCIsImxlbmd0aCIsIiRjcmVhdGUiLCJjcmVhdGUiLCJ1bmRlZmluZWQiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJFIiwiJGdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIiRnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm5hbWVzIiwicmVzdWx0IiwicHVzaCIsIiRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJJU19PUCIsIlR5cGVFcnJvciIsImFyZ3VtZW50cyIsIiRzZXQiLCJzZXQiLCJ0b1N0cmluZyIsIm5hbWUiLCJHIiwiVyIsIkYiLCJzeW1ib2xzIiwic3RvcmUiLCJTIiwia2V5Rm9yIiwidXNlU2V0dGVyIiwidXNlU2ltcGxlIiwiYXJncyIsInJlcGxhY2VyIiwiJHJlcGxhY2VyIiwiYXBwbHkiLCJ2YWx1ZU9mIiwiTWF0aCIsIndpbmRvdyIsInNlbGYiLCJfX2ciLCJoYXNPd25Qcm9wZXJ0eSIsImV4ZWMiLCJlIiwiY29yZSIsImhpZGUiLCJjdHgiLCJ0eXBlIiwic291cmNlIiwiSVNfRk9SQ0VEIiwiSVNfR0xPQkFMIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJJU19CSU5EIiwiQiIsInRhcmdldCIsImV4cFByb3RvIiwib3duIiwib3V0IiwiZXhwIiwiVSIsIlIiLCJ2ZXJzaW9uIiwiX19lIiwib2JqZWN0IiwiSUU4X0RPTV9ERUZJTkUiLCJBdHRyaWJ1dGVzIiwiaXNPYmplY3QiLCJkb2N1bWVudCIsImlzIiwiY3JlYXRlRWxlbWVudCIsImZuIiwidmFsIiwiYml0bWFwIiwiU1JDIiwiVE9fU1RSSU5HIiwiJHRvU3RyaW5nIiwiVFBMIiwiaW5zcGVjdFNvdXJjZSIsInNhZmUiLCJpc0Z1bmN0aW9uIiwiam9pbiIsImlkIiwicHgiLCJyYW5kb20iLCJjb25jYXQiLCJhRnVuY3Rpb24iLCJ0aGF0IiwiYiIsImMiLCJzZXREZXNjIiwiaXNFeHRlbnNpYmxlIiwiRlJFRVpFIiwicHJldmVudEV4dGVuc2lvbnMiLCJzZXRNZXRhIiwidyIsImZhc3RLZXkiLCJnZXRXZWFrIiwib25GcmVlemUiLCJtZXRhIiwiTkVFRCIsIlNIQVJFRCIsImRlZiIsIlRBRyIsInN0YXQiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJMSUJSQVJZIiwiY2hhckF0IiwiZ2V0S2V5cyIsImVsIiwiaW5kZXgiLCJlbnVtQnVnS2V5cyIsImFycmF5SW5kZXhPZiIsIklFX1BST1RPIiwiSU9iamVjdCIsImRlZmluZWQiLCJjb2YiLCJzbGljZSIsInRvTGVuZ3RoIiwidG9JbmRleCIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJmcm9tSW5kZXgiLCJ0b0ludGVnZXIiLCJtaW4iLCJjZWlsIiwiZmxvb3IiLCJpc05hTiIsIm1heCIsImdPUFMiLCJwSUUiLCJnZXRTeW1ib2xzIiwiYXJnIiwiZFBzIiwiRW1wdHkiLCJjcmVhdGVEaWN0IiwiaWZyYW1lIiwibHQiLCJndCIsImlmcmFtZURvY3VtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJzcmMiLCJjb250ZW50V2luZG93Iiwib3BlbiIsIndyaXRlIiwiY2xvc2UiLCJQcm9wZXJ0aWVzIiwiZG9jdW1lbnRFbGVtZW50Iiwid2luZG93TmFtZXMiLCJnZXRXaW5kb3dOYW1lcyIsImhpZGRlbktleXMiLCJmYWlscyIsInRvT2JqZWN0IiwiJGdldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIiRmcmVlemUiLCJmcmVlemUiLCIkc2VhbCIsInNlYWwiLCIkcHJldmVudEV4dGVuc2lvbnMiLCIkaXNGcm96ZW4iLCJpc0Zyb3plbiIsIiRpc1NlYWxlZCIsImlzU2VhbGVkIiwiJGlzRXh0ZW5zaWJsZSIsImFzc2lnbiIsIiRhc3NpZ24iLCJBIiwiSyIsImsiLCJUIiwiYUxlbiIsImoiLCJ4IiwieSIsInNldFByb3RvdHlwZU9mIiwiY2hlY2siLCJwcm90byIsInRlc3QiLCJidWdneSIsIl9fcHJvdG9fXyIsImNsYXNzb2YiLCJBUkciLCJ0cnlHZXQiLCJjYWxsZWUiLCJpbnZva2UiLCJhcnJheVNsaWNlIiwiZmFjdG9yaWVzIiwiY29uc3RydWN0IiwibGVuIiwibiIsInBhcnRBcmdzIiwiYm91bmQiLCJ1biIsIkZQcm90byIsIm5hbWVSRSIsIk5BTUUiLCJtYXRjaCIsIkhBU19JTlNUQU5DRSIsIkZ1bmN0aW9uUHJvdG8iLCIkcGFyc2VJbnQiLCJwYXJzZUludCIsIiR0cmltIiwidHJpbSIsIndzIiwiaGV4Iiwic3RyIiwicmFkaXgiLCJzdHJpbmciLCJzcGFjZXMiLCJzcGFjZSIsIm5vbiIsImx0cmltIiwiUmVnRXhwIiwicnRyaW0iLCJleHBvcnRlciIsIkFMSUFTIiwiRk9SQ0UiLCJUWVBFIiwicmVwbGFjZSIsIiRwYXJzZUZsb2F0IiwicGFyc2VGbG9hdCIsIkluZmluaXR5IiwiaW5oZXJpdElmUmVxdWlyZWQiLCJOVU1CRVIiLCIkTnVtYmVyIiwiQmFzZSIsIkJST0tFTl9DT0YiLCJUUklNIiwidG9OdW1iZXIiLCJhcmd1bWVudCIsImZpcnN0IiwiY2hhckNvZGVBdCIsInRoaXJkIiwibWF4Q29kZSIsIk5hTiIsImRpZ2l0cyIsImNvZGUiLCJOdW1iZXIiLCJDIiwiYU51bWJlclZhbHVlIiwicmVwZWF0IiwiJHRvRml4ZWQiLCJ0b0ZpeGVkIiwiZGF0YSIsIkVSUk9SIiwiWkVSTyIsIm11bHRpcGx5IiwiYzIiLCJkaXZpZGUiLCJudW1Ub1N0cmluZyIsInMiLCJ0IiwicG93IiwiYWNjIiwibG9nIiwieDIiLCJmcmFjdGlvbkRpZ2l0cyIsIm0iLCJ6IiwiUmFuZ2VFcnJvciIsIm1zZyIsImNvdW50IiwicmVzIiwiJHRvUHJlY2lzaW9uIiwidG9QcmVjaXNpb24iLCJwcmVjaXNpb24iLCJFUFNJTE9OIiwiX2lzRmluaXRlIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJudW1iZXIiLCJhYnMiLCJpc1NhZmVJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJsb2cxcCIsInNxcnQiLCIkYWNvc2giLCJhY29zaCIsIk1BWF9WQUxVRSIsIkxOMiIsIiRhc2luaCIsImFzaW5oIiwiJGF0YW5oIiwiYXRhbmgiLCJzaWduIiwiY2JydCIsImNsejMyIiwiTE9HMkUiLCJjb3NoIiwiJGV4cG0xIiwiZXhwbTEiLCJFUFNJTE9OMzIiLCJNQVgzMiIsIk1JTjMyIiwicm91bmRUaWVzVG9FdmVuIiwiZnJvdW5kIiwiJGFicyIsIiRzaWduIiwiaHlwb3QiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJzdW0iLCJsYXJnIiwiZGl2IiwiJGltdWwiLCJpbXVsIiwiVUlOVDE2IiwieG4iLCJ5biIsInhsIiwieWwiLCJsb2cxMCIsIkxOMTAiLCJsb2cyIiwic2luaCIsInRhbmgiLCJ0cnVuYyIsImZyb21DaGFyQ29kZSIsIiRmcm9tQ29kZVBvaW50IiwiZnJvbUNvZGVQb2ludCIsInJhdyIsImNhbGxTaXRlIiwidHBsIiwiJGF0IiwiaXRlcmF0ZWQiLCJfdCIsIl9pIiwicG9pbnQiLCJkb25lIiwicG9zIiwiSXRlcmF0b3JzIiwiJGl0ZXJDcmVhdGUiLCJJVEVSQVRPUiIsIkJVR0dZIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkNvbnN0cnVjdG9yIiwibmV4dCIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCJnZXRNZXRob2QiLCJraW5kIiwidmFsdWVzIiwiZW50cmllcyIsIkRFRl9WQUxVRVMiLCJWQUxVRVNfQlVHIiwiJG5hdGl2ZSIsIiRkZWZhdWx0IiwiJGVudHJpZXMiLCIkYW55TmF0aXZlIiwibWV0aG9kcyIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZGVzY3JpcHRvciIsImNvZGVQb2ludEF0IiwiY29udGV4dCIsIkVORFNfV0lUSCIsIiRlbmRzV2l0aCIsImVuZHNXaXRoIiwic2VhcmNoU3RyaW5nIiwiZW5kUG9zaXRpb24iLCJlbmQiLCJzZWFyY2giLCJpc1JlZ0V4cCIsIk1BVENIIiwicmUiLCJJTkNMVURFUyIsImluY2x1ZGVzIiwiaW5kZXhPZiIsIlNUQVJUU19XSVRIIiwiJHN0YXJ0c1dpdGgiLCJzdGFydHNXaXRoIiwiY3JlYXRlSFRNTCIsImFuY2hvciIsInF1b3QiLCJhdHRyaWJ1dGUiLCJwMSIsInRvTG93ZXJDYXNlIiwiYmlnIiwiYmxpbmsiLCJib2xkIiwiZml4ZWQiLCJmb250Y29sb3IiLCJjb2xvciIsImZvbnRzaXplIiwic2l6ZSIsIml0YWxpY3MiLCJsaW5rIiwidXJsIiwic21hbGwiLCJzdHJpa2UiLCJzdWIiLCJzdXAiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInRvSlNPTiIsInRvSVNPU3RyaW5nIiwicHYiLCJseiIsIm51bSIsImQiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01pbGxpc2Vjb25kcyIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJEYXRlUHJvdG8iLCJJTlZBTElEX0RBVEUiLCJoaW50IiwiaXNBcnJheUl0ZXIiLCJjcmVhdGVQcm9wZXJ0eSIsImdldEl0ZXJGbiIsIml0ZXIiLCJmcm9tIiwiYXJyYXlMaWtlIiwibWFwZm4iLCJtYXBwaW5nIiwiaXRlckZuIiwic3RlcCIsInJldCIsIkFycmF5UHJvdG8iLCJnZXRJdGVyYXRvck1ldGhvZCIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJhcnIiLCJvZiIsImFycmF5Sm9pbiIsInNlcGFyYXRvciIsIm1ldGhvZCIsImh0bWwiLCJiZWdpbiIsImtsYXNzIiwic3RhcnQiLCJ1cFRvIiwiY2xvbmVkIiwiJHNvcnQiLCJzb3J0IiwiY29tcGFyZWZuIiwiJGZvckVhY2giLCJTVFJJQ1QiLCJjYWxsYmFja2ZuIiwiYXNjIiwiSVNfTUFQIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIk5PX0hPTEVTIiwic3BlY2llc0NvbnN0cnVjdG9yIiwib3JpZ2luYWwiLCJTUEVDSUVTIiwiJG1hcCIsIm1hcCIsIiRmaWx0ZXIiLCJmaWx0ZXIiLCIkc29tZSIsInNvbWUiLCIkZXZlcnkiLCJldmVyeSIsIiRyZWR1Y2UiLCJyZWR1Y2UiLCJtZW1vIiwiaXNSaWdodCIsInJlZHVjZVJpZ2h0IiwiJGluZGV4T2YiLCJORUdBVElWRV9aRVJPIiwic2VhcmNoRWxlbWVudCIsImxhc3RJbmRleE9mIiwiY29weVdpdGhpbiIsInRvIiwiaW5jIiwiVU5TQ09QQUJMRVMiLCJmaWxsIiwiZW5kUG9zIiwiJGZpbmQiLCJmb3JjZWQiLCJmaW5kIiwiZmluZEluZGV4IiwiYWRkVG9VbnNjb3BhYmxlcyIsIkFyZ3VtZW50cyIsIiRmbGFncyIsIiRSZWdFeHAiLCJyZTEiLCJyZTIiLCJDT1JSRUNUX05FVyIsInAiLCJ0aVJFIiwicGlSRSIsImZpVSIsInByb3h5IiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsInVuaWNvZGUiLCJzdGlja3kiLCJmbGFncyIsIiRtYXRjaCIsInJlZ2V4cCIsIlNZTUJPTCIsImZucyIsInN0cmZuIiwicnhmbiIsIlJFUExBQ0UiLCIkcmVwbGFjZSIsInNlYXJjaFZhbHVlIiwicmVwbGFjZVZhbHVlIiwiU0VBUkNIIiwiJHNlYXJjaCIsIlNQTElUIiwiJHNwbGl0IiwiX3NwbGl0IiwiJHB1c2giLCIkU1BMSVQiLCJMRU5HVEgiLCJMQVNUX0lOREVYIiwiTlBDRyIsImxpbWl0Iiwib3V0cHV0IiwibGFzdExhc3RJbmRleCIsInNwbGl0TGltaXQiLCJzZXBhcmF0b3JDb3B5Iiwic2VwYXJhdG9yMiIsImxhc3RJbmRleCIsImxhc3RMZW5ndGgiLCJhbkluc3RhbmNlIiwiZm9yT2YiLCJ0YXNrIiwibWljcm90YXNrIiwiUFJPTUlTRSIsInByb2Nlc3MiLCIkUHJvbWlzZSIsImlzTm9kZSIsImVtcHR5IiwiSW50ZXJuYWwiLCJHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkiLCJXcmFwcGVyIiwicHJvbWlzZSIsInJlc29sdmUiLCJGYWtlUHJvbWlzZSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsInRoZW4iLCJzYW1lQ29uc3RydWN0b3IiLCJpc1RoZW5hYmxlIiwibmV3UHJvbWlzZUNhcGFiaWxpdHkiLCJQcm9taXNlQ2FwYWJpbGl0eSIsInJlamVjdCIsIiQkcmVzb2x2ZSIsIiQkcmVqZWN0IiwicGVyZm9ybSIsImVycm9yIiwibm90aWZ5IiwiaXNSZWplY3QiLCJfbiIsImNoYWluIiwiX2MiLCJfdiIsIm9rIiwiX3MiLCJydW4iLCJyZWFjdGlvbiIsImhhbmRsZXIiLCJmYWlsIiwiZG9tYWluIiwiX2giLCJvbkhhbmRsZVVuaGFuZGxlZCIsImVudGVyIiwiZXhpdCIsIm9uVW5oYW5kbGVkIiwiYWJydXB0IiwiY29uc29sZSIsImlzVW5oYW5kbGVkIiwiZW1pdCIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwicmVhc29uIiwiX2EiLCJvbnJlamVjdGlvbmhhbmRsZWQiLCIkcmVqZWN0IiwiX2QiLCJfdyIsIiRyZXNvbHZlIiwid3JhcHBlciIsIlByb21pc2UiLCJleGVjdXRvciIsImVyciIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInIiLCJjYXBhYmlsaXR5IiwiYWxsIiwiaXRlcmFibGUiLCJyZW1haW5pbmciLCIkaW5kZXgiLCJhbHJlYWR5Q2FsbGVkIiwicmFjZSIsImZvcmJpZGRlbkZpZWxkIiwiQlJFQUsiLCJSRVRVUk4iLCJjZWwiLCJzZXRUYXNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNvdW50ZXIiLCJxdWV1ZSIsIk9OUkVBRFlTVEFURUNIQU5HRSIsImRlZmVyIiwiY2hhbm5lbCIsInBvcnQiLCJsaXN0ZW5lciIsImV2ZW50IiwibmV4dFRpY2siLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsImNsZWFyIiwibWFjcm90YXNrIiwiT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImhlYWQiLCJsYXN0IiwiZmx1c2giLCJwYXJlbnQiLCJ0b2dnbGUiLCJub2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInN0cm9uZyIsIk1hcCIsImVudHJ5IiwiZ2V0RW50cnkiLCJ2IiwicmVkZWZpbmVBbGwiLCIkaXRlckRlZmluZSIsInNldFNwZWNpZXMiLCJTSVpFIiwiX2YiLCJnZXRDb25zdHJ1Y3RvciIsIkFEREVSIiwiX2wiLCJwcmV2Iiwic2V0U3Ryb25nIiwiJGl0ZXJEZXRlY3QiLCJjb21tb24iLCJJU19XRUFLIiwiZml4TWV0aG9kIiwiYWRkIiwiaW5zdGFuY2UiLCJIQVNOVF9DSEFJTklORyIsIlRIUk9XU19PTl9QUklNSVRJVkVTIiwiQUNDRVBUX0lURVJBQkxFUyIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCJTZXQiLCJlYWNoIiwid2VhayIsInVuY2F1Z2h0RnJvemVuU3RvcmUiLCJ1ZnN0b3JlIiwidG1wIiwiSW50ZXJuYWxNYXAiLCJXZWFrTWFwIiwiJFdlYWtNYXAiLCJjcmVhdGVBcnJheU1ldGhvZCIsIiRoYXMiLCJhcnJheUZpbmQiLCJhcnJheUZpbmRJbmRleCIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCJzcGxpY2UiLCJXZWFrU2V0IiwiJHR5cGVkIiwiYnVmZmVyIiwiQXJyYXlCdWZmZXIiLCIkQXJyYXlCdWZmZXIiLCIkRGF0YVZpZXciLCJEYXRhVmlldyIsIiRpc1ZpZXciLCJBQlYiLCJpc1ZpZXciLCIkc2xpY2UiLCJWSUVXIiwiQVJSQVlfQlVGRkVSIiwiQ09OU1RSIiwiYnl0ZUxlbmd0aCIsImZpbmFsIiwidmlld1MiLCJ2aWV3VCIsInNldFVpbnQ4IiwiZ2V0VWludDgiLCJUWVBFRCIsIlR5cGVkIiwiVHlwZWRBcnJheUNvbnN0cnVjdG9ycyIsImFycmF5RmlsbCIsIkRBVEFfVklFVyIsIldST05HX0xFTkdUSCIsIldST05HX0lOREVYIiwiQmFzZUJ1ZmZlciIsIkJVRkZFUiIsIkJZVEVfTEVOR1RIIiwiQllURV9PRkZTRVQiLCIkQlVGRkVSIiwiJExFTkdUSCIsIiRPRkZTRVQiLCJwYWNrSUVFRTc1NCIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwicnQiLCJ1bnBhY2tJRUVFNzU0IiwibkJpdHMiLCJ1bnBhY2tJMzIiLCJieXRlcyIsInBhY2tJOCIsInBhY2tJMTYiLCJwYWNrSTMyIiwicGFja0Y2NCIsInBhY2tGMzIiLCJhZGRHZXR0ZXIiLCJpbnRlcm5hbCIsInZpZXciLCJpc0xpdHRsZUVuZGlhbiIsIm51bUluZGV4IiwiaW50SW5kZXgiLCJfYiIsInBhY2siLCJyZXZlcnNlIiwiY29udmVyc2lvbiIsInZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMiLCJudW1iZXJMZW5ndGgiLCJieXRlT2Zmc2V0IiwiYnVmZmVyTGVuZ3RoIiwib2Zmc2V0IiwiZ2V0SW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJnZXRGbG9hdDMyIiwiZ2V0RmxvYXQ2NCIsInNldEludDgiLCJzZXRJbnQxNiIsInNldFVpbnQxNiIsInNldEludDMyIiwic2V0VWludDMyIiwic2V0RmxvYXQzMiIsInNldEZsb2F0NjQiLCJBcnJheUJ1ZmZlclByb3RvIiwiJHNldEludDgiLCJpbml0IiwiSW50OEFycmF5IiwiJGJ1ZmZlciIsInByb3BlcnR5RGVzYyIsInNhbWUiLCJjcmVhdGVBcnJheUluY2x1ZGVzIiwiQXJyYXlJdGVyYXRvcnMiLCJhcnJheUNvcHlXaXRoaW4iLCJVaW50OEFycmF5IiwiU0hBUkVEX0JVRkZFUiIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiYXJyYXlGb3JFYWNoIiwiYXJyYXlGaWx0ZXIiLCJhcnJheVNvbWUiLCJhcnJheUV2ZXJ5IiwiYXJyYXlJbmNsdWRlcyIsImFycmF5VmFsdWVzIiwiYXJyYXlLZXlzIiwiYXJyYXlFbnRyaWVzIiwiYXJyYXlMYXN0SW5kZXhPZiIsImFycmF5UmVkdWNlIiwiYXJyYXlSZWR1Y2VSaWdodCIsImFycmF5U29ydCIsImFycmF5VG9TdHJpbmciLCJhcnJheVRvTG9jYWxlU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJUWVBFRF9DT05TVFJVQ1RPUiIsIkRFRl9DT05TVFJVQ1RPUiIsIkFMTF9DT05TVFJVQ1RPUlMiLCJUWVBFRF9BUlJBWSIsImFsbG9jYXRlIiwiTElUVExFX0VORElBTiIsIlVpbnQxNkFycmF5IiwiRk9SQ0VEX1NFVCIsInN0cmljdFRvTGVuZ3RoIiwiU0FNRSIsInRvT2Zmc2V0IiwiQllURVMiLCJ2YWxpZGF0ZSIsInNwZWNpZXNGcm9tTGlzdCIsImxpc3QiLCJmcm9tTGlzdCIsIiRmcm9tIiwiJG9mIiwiVE9fTE9DQUxFX0JVRyIsIiR0b0xvY2FsZVN0cmluZyIsInByZWRpY2F0ZSIsIm1pZGRsZSIsInN1YmFycmF5IiwiJGJlZ2luIiwiJGl0ZXJhdG9ycyIsImlzVEFJbmRleCIsIiRnZXREZXNjIiwiJHNldERlc2MiLCJkZXNjIiwiJFR5cGVkQXJyYXlQcm90b3R5cGUkIiwiQ0xBTVBFRCIsIklTTlRfVUlOVDgiLCJHRVRURVIiLCJTRVRURVIiLCJUeXBlZEFycmF5IiwiVEFDIiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdldHRlciIsIm8iLCJyb3VuZCIsImFkZEVsZW1lbnQiLCIkb2Zmc2V0IiwiJGxlbmd0aCIsIiRsZW4iLCIkbmF0aXZlSXRlcmF0b3IiLCJDT1JSRUNUX0lURVJfTkFNRSIsIiRpdGVyYXRvciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsInJBcHBseSIsIlJlZmxlY3QiLCJmQXBwbHkiLCJ0aGlzQXJndW1lbnQiLCJhcmd1bWVudHNMaXN0IiwiTCIsInJDb25zdHJ1Y3QiLCJORVdfVEFSR0VUX0JVRyIsIkFSR1NfQlVHIiwiVGFyZ2V0IiwibmV3VGFyZ2V0IiwiJGFyZ3MiLCJwcm9wZXJ0eUtleSIsImF0dHJpYnV0ZXMiLCJkZWxldGVQcm9wZXJ0eSIsIkVudW1lcmF0ZSIsImVudW1lcmF0ZSIsInJlY2VpdmVyIiwiZ2V0UHJvdG8iLCJvd25LZXlzIiwiViIsIm93bkRlc2MiLCJleGlzdGluZ0Rlc2NyaXB0b3IiLCJzZXRQcm90byIsIiRpbmNsdWRlcyIsImF0IiwiJHBhZCIsIm1heExlbmd0aCIsImZpbGxTdHJpbmciLCJsZWZ0Iiwic3RyaW5nTGVuZ3RoIiwiZmlsbFN0ciIsImludE1heExlbmd0aCIsImZpbGxMZW4iLCJzdHJpbmdGaWxsZXIiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsImdldEZsYWdzIiwiUmVnRXhwUHJvdG8iLCIkUmVnRXhwU3RyaW5nSXRlcmF0b3IiLCJfciIsIm1hdGNoQWxsIiwicngiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZ2V0RGVzYyIsIiR2YWx1ZXMiLCJpc0VudHJpZXMiLCJfX2RlZmluZUdldHRlcl9fIiwiX19kZWZpbmVTZXR0ZXJfXyIsIl9fbG9va3VwR2V0dGVyX18iLCJfX2xvb2t1cFNldHRlcl9fIiwiaXNFcnJvciIsImlhZGRoIiwieDAiLCJ4MSIsInkwIiwieTEiLCIkeDAiLCIkeDEiLCIkeTAiLCJpc3ViaCIsImltdWxoIiwidSIsIiR1IiwiJHYiLCJ1MCIsInYwIiwidTEiLCJ2MSIsInVtdWxoIiwibWV0YWRhdGEiLCJ0b01ldGFLZXkiLCJvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhIiwiZGVmaW5lTWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJ0YXJnZXRLZXkiLCJnZXRPckNyZWF0ZU1ldGFkYXRhTWFwIiwidGFyZ2V0TWV0YWRhdGEiLCJrZXlNZXRhZGF0YSIsIm9yZGluYXJ5SGFzT3duTWV0YWRhdGEiLCJNZXRhZGF0YUtleSIsIm1ldGFkYXRhTWFwIiwib3JkaW5hcnlHZXRPd25NZXRhZGF0YSIsIk1ldGFkYXRhVmFsdWUiLCJvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyIsIl8iLCJkZWxldGVNZXRhZGF0YSIsIm9yZGluYXJ5R2V0TWV0YWRhdGEiLCJoYXNPd24iLCJnZXRNZXRhZGF0YSIsIm9yZGluYXJ5TWV0YWRhdGFLZXlzIiwib0tleXMiLCJwS2V5cyIsImdldE1ldGFkYXRhS2V5cyIsImdldE93bk1ldGFkYXRhIiwiZ2V0T3duTWV0YWRhdGFLZXlzIiwib3JkaW5hcnlIYXNNZXRhZGF0YSIsImhhc01ldGFkYXRhIiwiaGFzT3duTWV0YWRhdGEiLCJkZWNvcmF0b3IiLCJhc2FwIiwiT0JTRVJWQUJMRSIsImNsZWFudXBTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwic3Vic2NyaXB0aW9uQ2xvc2VkIiwiX28iLCJjbG9zZVN1YnNjcmlwdGlvbiIsIlN1YnNjcmlwdGlvbiIsIm9ic2VydmVyIiwic3Vic2NyaWJlciIsIlN1YnNjcmlwdGlvbk9ic2VydmVyIiwidW5zdWJzY3JpYmUiLCJjb21wbGV0ZSIsIiRPYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsInN1YnNjcmliZSIsIm9ic2VydmFibGUiLCJpdGVtcyIsInBhcnRpYWwiLCJuYXZpZ2F0b3IiLCJNU0lFIiwidXNlckFnZW50IiwidGltZSIsInNldEludGVydmFsIiwicGF0aCIsInBhcmdzIiwiaG9sZGVyIiwiJHRhc2siLCJUT19TVFJJTkdfVEFHIiwiQXJyYXlWYWx1ZXMiLCJjb2xsZWN0aW9ucyIsIkNvbGxlY3Rpb24iLCJPcCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiaW5Nb2R1bGUiLCJydW50aW1lIiwicmVnZW5lcmF0b3JSdW50aW1lIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiQ29udGV4dCIsIl9pbnZva2UiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJvYmoiLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibWFyayIsImF3cmFwIiwiX19hd2FpdCIsIkFzeW5jSXRlcmF0b3IiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsInN0YXRlIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJyZXR1cm4iLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsInBvcCIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImZpbmlzaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImNoaWxkcmVuIiwiZXNjYXBlIiwiJHJlIiwicmVnRXhwIiwicGFydCIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJtYWtlTWFwIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsInJlbW92ZSIsIml0ZW0iLCJjYWNoZWQiLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJib3VuZEZuIiwiX2xlbmd0aCIsInRvQXJyYXkiLCJleHRlbmQiLCJfZnJvbSIsIm5vb3AiLCJubyIsImlkZW50aXR5IiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsImVudiIsIk5PREVfRU5WIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsImlnbm9yZWRFbGVtZW50cyIsImtleUNvZGVzIiwiaXNSZXNlcnZlZFRhZyIsImlzUmVzZXJ2ZWRBdHRyIiwiaXNVbmtub3duRWxlbWVudCIsImdldFRhZ05hbWVzcGFjZSIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwibXVzdFVzZVByb3AiLCJfbGlmZWN5Y2xlSG9va3MiLCJlbXB0eU9iamVjdCIsImlzUmVzZXJ2ZWQiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJzZWdtZW50cyIsIndhcm4iLCJ0aXAiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsInZtIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJvcHRpb25zIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwiaGFuZGxlRXJyb3IiLCJpbkJyb3dzZXIiLCJoYXNQcm90byIsIlVBIiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsInRpbWVyRnVuYyIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsImxvZ0Vycm9yIiwiY2F0Y2giLCJ0ZXh0Tm9kZSIsInF1ZXVlTmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwiX1NldCIsInVpZCQxIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibXV0YXRvciIsImFyZ3VtZW50cyQxIiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwiYXNSb290RGF0YSIsImN1c3RvbVNldHRlciIsInByb3BlcnR5IiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsImRlbCIsInN0cmF0cyIsInByb3BzRGF0YSIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwidG9WYWwiLCJmcm9tVmFsIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwid2F0Y2giLCJwcm9wcyIsImNvbXB1dGVkIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiaXNUeXBlIiwiQm9vbGVhbiIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJWTm9kZSIsInRleHQiLCJlbG0iLCJjb21wb25lbnRPcHRpb25zIiwibnMiLCJmdW5jdGlvbmFsQ29udGV4dCIsImNvbXBvbmVudEluc3RhbmNlIiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZVZOb2RlcyIsInZub2RlcyIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjYXB0dXJlIiwiY3JlYXRlRm5JbnZva2VyIiwiaW52b2tlciIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJmYWN0b3J5IiwiYmFzZUN0b3IiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsImNvbnRleHRzIiwic3luYyIsImZvcmNlUmVuZGVyIiwiJGZvcmNlVXBkYXRlIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiVnVlIiwiaG9va1JFIiwidGhpcyQxIiwiaSQxIiwiY2JzIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwiZGVmYXVsdFNsb3QiLCJzbG90IiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCIkZGVzdHJveSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCIkc2xvdHMiLCJpc0luSW5hY3RpdmVUcmVlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRpcmVjdCIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsIk1BWF9VUERBVEVfQ09VTlQiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVIb29rcyIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwidHJhdmVyc2UiLCJjbGVhbnVwRGVwcyIsIm9sZFZhbHVlIiwiZXZhbHVhdGUiLCJzZWVuT2JqZWN0cyIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJkZXBJZCIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwiaXNSZXNlcnZlZFByb3AiLCJyZWYiLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJsb29wIiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwidXNlckRlZiIsImRlZmluZUNvbXB1dGVkIiwiJGRhdGEiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCJuZXdEYXRhIiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwicHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsImluamVjdCIsInByb3ZpZGVLZXkiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsIl9jb250ZXh0IiwiaCIsImluamVjdGlvbnMiLCJmdW5jdGlvbmFsT3B0aW9ucyIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJhcHBseU5TIiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCJyZXNvbHZlRmlsdGVyIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImRvbVByb3BzIiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiaW5pdFJlbmRlciIsInJlbmRlckNvbnRleHQiLCIkY3JlYXRlRWxlbWVudCIsInJlbmRlck1peGluIiwiJG5leHRUaWNrIiwicmVuZGVyRXJyb3IiLCJfcSIsIl9tIiwiX2UiLCJfdSIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWQiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsInBhdHRlcm5UeXBlcyIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJjdXJyZW50IiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImRlbGV0ZSIsInNzckNvbnRleHQiLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJnZW5DbGFzc0Zyb21EYXRhIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJtb2R1bGVzIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaW5QcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJwcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJhbmNlc3RvciIsIl9zY29wZUlkIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwiZWxtVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoeWRyYXRlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImRpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwid3JhcEZpbHRlciIsImluZGV4JDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwibm9ybWFsaXplRXZlbnRzIiwidGFyZ2V0JDEiLCJhZGQkMSIsIm9sZEhhbmRsZXIiLCJldiIsInJlbW92ZSQyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsImV2ZW50cyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJwcmVmaXhlcyIsInRlc3RFbCIsInVwcGVyIiwicHJlZml4ZWQiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJtb2RlbCQxIiwiYmluZGluZyIsInNldFNlbGVjdGVkIiwib25Db21wb3NpdGlvbkVuZCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJpc011bHRpcGxlIiwib3B0aW9uIiwiZ2V0VmFsdWUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsImtleSQxIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiYm9keSIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJJdGVtIiwiYXJyYXkiLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbnMiLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJhcHAiLCJtb2QiLCJBc3luY0NvbXB1dGVkIiwicHJlZml4IiwicGx1Z2luT3B0aW9ucyIsImFzeW5jQ29tcHV0ZWQiLCJiZWZvcmVDcmVhdGUiLCJvcHRpb25EYXRhIiwiZ2V0dGVyRm9yIiwidnVlQXN5bmNDb21wdXRlZEluamVjdGVkRGF0YUZuIiwiX2tleSIsIl90aGlzIiwiZGVmYXVsdEZvciIsIl9sb29wIiwiX2tleTIiLCJwcm9taXNlSWQiLCJuZXdQcm9taXNlIiwidGhpc1Byb21pc2UiLCJ1c2VSYXdFcnJvciIsInN0YWNrIiwiZGVmYXVsdFZhbHVlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdENBOztBQUVBLG9CQUFBQSxDQUFRLENBQVI7O0FBRUEsb0JBQUFBLENBQVEsR0FBUjs7QUFFQSxvQkFBQUEsQ0FBUSxHQUFSOztBQUVBLEtBQUlDLE9BQU9DLGNBQVgsRUFBMkI7QUFDekIsU0FBTSxJQUFJQyxLQUFKLENBQVUsZ0RBQVYsQ0FBTjtBQUNEO0FBQ0RGLFFBQU9DLGNBQVAsR0FBd0IsSUFBeEI7O0FBRUEsS0FBSUUsa0JBQWtCLGdCQUF0QjtBQUNBLFVBQVNDLE1BQVQsQ0FBZ0JDLENBQWhCLEVBQW1CQyxHQUFuQixFQUF3QkMsS0FBeEIsRUFBK0I7QUFDN0JGLEtBQUVDLEdBQUYsS0FBVUUsT0FBT0wsZUFBUCxFQUF3QkUsQ0FBeEIsRUFBMkJDLEdBQTNCLEVBQWdDO0FBQ3hDRyxlQUFVLElBRDhCO0FBRXhDQyxtQkFBYyxJQUYwQjtBQUd4Q0gsWUFBT0E7QUFIaUMsSUFBaEMsQ0FBVjtBQUtEOztBQUVESCxRQUFPTyxPQUFPQyxTQUFkLEVBQXlCLFNBQXpCLEVBQW9DLEdBQUdDLFFBQXZDO0FBQ0FULFFBQU9PLE9BQU9DLFNBQWQsRUFBeUIsVUFBekIsRUFBcUMsR0FBR0UsTUFBeEM7O0FBRUEsaU1BQWdNQyxLQUFoTSxDQUFzTSxHQUF0TSxFQUEyTUMsT0FBM00sQ0FBbU4sVUFBVVYsR0FBVixFQUFlO0FBQ2hPLE1BQUdBLEdBQUgsS0FBV0YsT0FBT2EsS0FBUCxFQUFjWCxHQUFkLEVBQW1CWSxTQUFTQyxJQUFULENBQWNDLElBQWQsQ0FBbUIsR0FBR2QsR0FBSCxDQUFuQixDQUFuQixDQUFYO0FBQ0QsRUFGRCxFOzs7Ozs7Ozs7QUN6QkEsb0JBQUFQLENBQVEsQ0FBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEVBQVI7QUFDQSxvQkFBQUEsQ0FBUSxFQUFSO0FBQ0Esb0JBQUFBLENBQVEsRUFBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEsQ0FBUSxHQUFSO0FBQ0Esb0JBQUFBLENBQVEsR0FBUjtBQUNBLG9CQUFBQSxDQUFRLEdBQVI7QUFDQSxvQkFBQUEs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InRhYi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDBkMWM2NmRhOTM2OTVkMjEzMmJjIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL3NoaW0uanMiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fa2V5b2YuanMiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpfSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRrZXlzICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbigkZnJlZXplKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbigkc2VhbCl7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KXtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbigkaXNGcm96ZW4pe1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbigkaXNFeHRlbnNpYmxlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7aXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywge2JpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGhhcyAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEZQcm90byAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGVcbiAgLCBuYW1lUkUgICAgID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvXG4gICwgTkFNRSAgICAgICA9ICduYW1lJztcblxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKXtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAgICwgbmFtZSA9ICgnJyArIHRoYXQpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICBoYXModGhhdCwgTkFNRSkgfHwgIWlzRXh0ZW5zaWJsZSh0aGF0KSB8fCBkUCh0aGF0LCBOQU1FLCBjcmVhdGVEZXNjKDUsIG5hbWUpKTtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBIQVNfSU5TVEFOQ0UgICA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byAgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHtwYXJzZUludDogJHBhcnNlSW50fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludFxuICAsICR0cmltICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIHdzICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgaGV4ICAgICAgID0gL15bXFwtK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCl7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdFxuICAsICR0cmltICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cil7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMylcbiAgICAsIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJ2YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCB0YXJnZXQsIEMpe1xuICB2YXIgUCwgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgaWYoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZil7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbnRlZ2VyICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsIHJlcGVhdCAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsICR0b0ZpeGVkICAgICA9IDEuLnRvRml4ZWRcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgZGF0YSAgICAgICAgID0gWzAsIDAsIDAsIDAsIDAsIDBdXG4gICwgRVJST1IgICAgICAgID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbihuLCBjKXtcbiAgdmFyIGkgID0gLTFcbiAgICAsIGMyID0gYztcbiAgd2hpbGUoKytpIDwgNil7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgaSA9IDZcbiAgICAsIGMgPSAwO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDZcbiAgICAsIHMgPSAnJztcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xuICB2YXIgbiAgPSAwXG4gICAgLCB4MiA9IHg7XG4gIHdoaWxlKHgyID49IDQwOTYpe1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSh4MiA+PSAyKXtcbiAgICBuICArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cyl7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXG4gICAgICAsIHMgPSAnJ1xuICAgICAgLCBtID0gWkVST1xuICAgICAgLCBlLCB6LCBqLCBrO1xuICAgIGlmKGYgPCAwIHx8IGYgPiAyMCl0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICBpZih4ICE9IHgpcmV0dXJuICdOYU4nO1xuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYoeCA8IDApe1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYoeCA+IDFlLTIxKXtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYoZSA+IDApe1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlKGogPj0gNyl7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUoaiA+PSAyMyl7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihmID4gMCl7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIG1zZyl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsICR0b1ByZWNpc2lvbiA9IDEuLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pe1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTsgXG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge0VQU0lMT046IE1hdGgucG93KDIsIC01Mil9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpfSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZsb29yICAgID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmZ9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHtwYXJzZUludDogJHBhcnNlSW50fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbG9nMXAgICA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKVxuICAsIHNxcnQgICAgPSBNYXRoLnNxcnRcbiAgLCAkYWNvc2ggID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU4gXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXNpbmggID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywge2FzaW5oOiBhc2luaH0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdGFuaCAgPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDAgXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KXtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KXtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpe1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRleHBtMSAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7ZXhwbTE6ICRleHBtMX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwbTEgPSBNYXRoLmV4cG0xO1xubW9kdWxlLmV4cG9ydHMgPSAoISRleHBtMVxuICAvLyBPbGQgRkYgYnVnXG4gIHx8ICRleHBtMSgxMCkgPiAyMjAyNS40NjU3OTQ4MDY3MTkgfHwgJGV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcbiAgLy8gVG9yIEJyb3dzZXIgYnVnXG4gIHx8ICRleHBtMSgtMmUtMTcpICE9IC0yZS0xN1xuKSA/IGZ1bmN0aW9uIGV4cG0xKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJylcbiAgLCBwb3cgICAgICAgPSBNYXRoLnBvd1xuICAsIEVQU0lMT04gICA9IHBvdygyLCAtNTIpXG4gICwgRVBTSUxPTjMyID0gcG93KDIsIC0yMylcbiAgLCBNQVgzMiAgICAgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKVxuICAsIE1JTjMyICAgICA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnJvdW5kOiBmdW5jdGlvbiBmcm91bmQoeCl7XG4gICAgdmFyICRhYnMgID0gTWF0aC5hYnMoeClcbiAgICAgICwgJHNpZ24gPSBzaWduKHgpXG4gICAgICAsIGEsIHJlc3VsdDtcbiAgICBpZigkYWJzIDwgTUlOMzIpcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gICAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gICAgaWYocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdClyZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFicyAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSAgPSAwXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGxhcmcgPSAwXG4gICAgICAsIGFyZywgZGl2O1xuICAgIHdoaWxlKGkgPCBhTGVuKXtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZihsYXJnIDwgYXJnKXtcbiAgICAgICAgZGl2ICA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSAgPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmKGFyZyA+IDApe1xuICAgICAgICBkaXYgID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGltdWwgICA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSl7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCB4biA9ICt4XG4gICAgICAsIHluID0gK3lcbiAgICAgICwgeGwgPSBVSU5UMTYgJiB4blxuICAgICAgLCB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7bG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpfSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHBtMSAgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4vLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KXtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDFcbiAgICAgID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDJcbiAgICAgIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpe1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxuICAgICAgLCBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsInZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbmRleCAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgZnJvbUNoYXJDb2RlICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICwgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzICA9IFtdXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGNvZGU7XG4gICAgd2hpbGUoYUxlbiA+IGkpe1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSl7XG4gICAgdmFyIHRwbCAgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KVxuICAgICAgLCBsZW4gID0gdG9MZW5ndGgodHBsLmxlbmd0aClcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzICA9IFtdXG4gICAgICAsIGkgICAgPSAwO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZihpIDwgYUxlbilyZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIEVORFNfV0lUSCA9ICdlbmRzV2l0aCdcbiAgLCAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxuICAgICAgLCBlbmQgICAgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSl7XG4gIGlmKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgTUFUQ0ggICAgPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2goZSl7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoKGYpeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb250ZXh0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJ1xuICAsICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgdmFyIHRoYXQgICA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSClcbiAgICAgICwgaW5kZXggID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSlcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBxdW90ICAgID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24oc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSlcbiAgICAsIHAxID0gJzwnICsgdGFnO1xuICBpZihhdHRyaWJ1dGUgIT09ICcnKXAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgZXhlYyl7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy43IFN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yKGNvbG9yKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udGNvbG9yJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3Ipe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywge25vdzogZnVuY3Rpb24oKXsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHt0b0lTT1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH19KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KXtcbiAgICB2YXIgTyAgPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG5cbnZhciBseiA9IGZ1bmN0aW9uKG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoLTVlMTMgLSAxKS50b0lTT1N0cmluZygpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTtcbn0pKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpe1xuICAgIGlmKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICAgIHZhciBkID0gdGhpc1xuICAgICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgICAsIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gICAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICAgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArXG4gICAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsInZhciBEYXRlUHJvdG8gICAgPSBEYXRlLnByb3RvdHlwZVxuICAsIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnXG4gICwgVE9fU1RSSU5HICAgID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyAgICA9IERhdGVQcm90b1tUT19TVFJJTkddXG4gICwgZ2V0VGltZSAgICAgID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZihuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJylcbiAgLCBwcm90byAgICAgICAgPSBEYXRlLnByb3RvdHlwZTtcblxuaWYoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKXJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBOVU1CRVIgICAgICA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhpbnQpe1xuICBpZihoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKXRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUoYUxlbiA+IGluZGV4KWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3Ipe1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZCwgYXJnKXtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24oKXt9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaHRtbCAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNvZiAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIHRvSW5kZXggICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgaWYoaHRtbClhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCl7XG4gICAgdmFyIGxlbiAgID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpXG4gICAgICAsIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmKGtsYXNzID09ICdBcnJheScpcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgID0gdG9JbmRleChiZWdpbiwgbGVuKVxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBzaXplICAgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpXG4gICAgICAsIGNsb25lZCA9IEFycmF5KHNpemUpXG4gICAgICAsIGkgICAgICA9IDA7XG4gICAgZm9yKDsgaSA8IHNpemU7IGkrKyljbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGZhaWxzICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkc29ydCAgICAgPSBbXS5zb3J0XG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgU1RSSUNUICAgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJG1hcCAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkc29tZSAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXZlcnkgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5kZXhPZiAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCAkbmF0aXZlICAgICAgID0gW10uaW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvSW50ZWdlciAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCAkbmF0aXZlICAgICAgID0gW10ubGFzdEluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IEBbKi0xXSAqLyl7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmKE5FR0FUSVZFX1pFUk8pcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QodGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IGxlbmd0aCAtIDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KXJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7Y29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKX0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQvKj0gMCovLCBzdGFydC8qPSAwLCBlbmQgPSBAbGVuZ3RoKi8pe1xuICB2YXIgTyAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuICAgPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcbiAgICAsIGZyb20gID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICwgZW5kICAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0bylcbiAgICAsIGluYyAgID0gMTtcbiAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcbiAgICBpbmMgID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gICArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUoY291bnQtLSA+IDApe1xuICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gICArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpXG4gICwgQXJyYXlQcm90byAgPSBBcnJheS5wcm90b3R5cGU7XG5pZihBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2ZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKX0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KVxuICAsIEtFWSAgICAgPSAnZmluZCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KVxuICAsIEtFWSAgICAgPSAnZmluZEluZGV4J1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZihERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKWRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsInZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGlzUmVnRXhwICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCAkZmxhZ3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCAkUmVnRXhwICAgICAgICAgICA9IGdsb2JhbC5SZWdFeHBcbiAgLCBCYXNlICAgICAgICAgICAgICA9ICRSZWdFeHBcbiAgLCBwcm90byAgICAgICAgICAgICA9ICRSZWdFeHAucHJvdG90eXBlXG4gICwgcmUxICAgICAgICAgICAgICAgPSAvYS9nXG4gICwgcmUyICAgICAgICAgICAgICAgPSAvYS9nXG4gIC8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxuICAsIENPUlJFQ1RfTkVXICAgICAgID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKXtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKXtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwXG4gICAgICAsIHBpUkUgPSBpc1JlZ0V4cChwKVxuICAgICAgLCBmaVUgID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uKGtleSl7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGl0KXsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTsgKXByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgICA9IGFuT2JqZWN0KHRoaXMpXG4gICAgLCByZXN1bHQgPSAnJztcbiAgaWYodGhhdC5nbG9iYWwpICAgICByZXN1bHQgKz0gJ2cnO1xuICBpZih0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmKHRoYXQubXVsdGlsaW5lKSAgcmVzdWx0ICs9ICdtJztcbiAgaWYodGhhdC51bmljb2RlKSAgICByZXN1bHQgKz0gJ3UnO1xuICBpZih0aGF0LnN0aWNreSkgICAgIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkZmxhZ3MgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe3NvdXJjZTogJ2EnLCBmbGFnczogJ2InfSkgIT0gJy9hL2InOyB9KSl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbihkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKXtcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIG1hdGNoKHJlZ2V4cCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJG1hdGNoXTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBmYWlscyAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHdrcyAgICAgID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBsZW5ndGgsIGV4ZWMpe1xuICB2YXIgU1lNQk9MICAgPSB3a3MoS0VZKVxuICAgICwgZm5zICAgICAgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSlcbiAgICAsIHN0cmZuICAgID0gZm5zWzBdXG4gICAgLCByeGZuICAgICA9IGZuc1sxXTtcbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKXtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uKHN0cmluZywgYXJnKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbihzdHJpbmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzIiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSl7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIFNFQVJDSCwgJHNlYXJjaCl7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFNQTElULCAkc3BsaXQpe1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgICAsIF9zcGxpdCAgICAgPSAkc3BsaXRcbiAgICAsICRwdXNoICAgICAgPSBbXS5wdXNoXG4gICAgLCAkU1BMSVQgICAgID0gJ3NwbGl0J1xuICAgICwgTEVOR1RIICAgICA9ICdsZW5ndGgnXG4gICAgLCBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApe1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmKCFpc1JlZ0V4cChzZXBhcmF0b3IpKXJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmKCFOUENHKXNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZShtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKXtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpe1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgaWYoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspaWYoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZihsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSl7XG4gICAgICAgIGlmKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSl7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNsYXNzb2YgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbkluc3RhbmNlICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCB0YXNrICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgbWljcm90YXNrICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIFBST01JU0UgICAgICAgICAgICA9ICdQcm9taXNlJ1xuICAsIFR5cGVFcnJvciAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsICRQcm9taXNlICAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICAgICAgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBlbXB0eSAgICAgICAgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgSW50ZXJuYWwsIEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgICAgID0gJFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgLCBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24oZXhlYyl7IGV4ZWMoZW1wdHksIGVtcHR5KTsgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyB3aXRoIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSA9PT0gJFByb21pc2UgJiYgYiA9PT0gV3JhcHBlcjtcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgcmV0dXJuIHNhbWVDb25zdHJ1Y3RvcigkUHJvbWlzZSwgQylcbiAgICA/IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgIDogbmV3IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xudmFyIHBlcmZvcm0gPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNSZWplY3Qpe1xuICBpZihwcm9taXNlLl9uKXJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgb2sgICAgPSBwcm9taXNlLl9zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgZG9tYWluICA9IHJlYWN0aW9uLmRvbWFpblxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvayl7XG4gICAgICAgICAgICBpZihwcm9taXNlLl9oID09IDIpb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGFuZGxlciA9PT0gdHJ1ZSlyZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSl7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKW9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIGFicnVwdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYoYWJydXB0KXRocm93IGFicnVwdC5lcnJvcjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIGlmKHByb21pc2UuX2ggPT0gMSlyZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fY1xuICAgICwgaSAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZihpc05vZGUpe1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKXtcbiAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdn0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYoIXByb21pc2UuX2EpcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHByb21pc2UgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7X3c6IHByb21pc2UsIF9kOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe193OiBwcm9taXNlLCBfZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIVVTRV9OQVRJVkUpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiAgICA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgICAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsICAgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9hKXRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9zKW5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwcm9taXNlICA9IG5ldyBJbnRlcm5hbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogJFByb21pc2V9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mICRQcm9taXNlICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIHZhciB2YWx1ZXMgICAgPSBbXVxuICAgICAgICAsIGluZGV4ICAgICA9IDBcbiAgICAgICAgLCByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgdmFyICRpbmRleCAgICAgICAgPSBpbmRleCsrXG4gICAgICAgICAgLCBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCAgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgbWV0YSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsICRpdGVyRGV0ZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnICAgID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24oS0VZKXtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSl7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYil7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZih0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlICAgICAgICAgICAgID0gbmV3IENcbiAgICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICAgICwgSEFTTlRfQ0hBSU5JTkcgICAgICAgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlXG4gICAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICAgICwgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbigpeyBpbnN0YW5jZS5oYXMoMSk7IH0pXG4gICAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgICAsIEFDQ0VQVF9JVEVSQUJMRVMgICAgID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7IG5ldyBDKGl0ZXIpOyB9KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgICAsIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKClcbiAgICAgICAgICAsIGluZGV4ICAgICA9IDU7XG4gICAgICAgIHdoaWxlKGluZGV4LS0pJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgICAgfSk7XG4gICAgaWYoIUFDQ0VQVF9JVEVSQUJMRVMpeyBcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UsIHRhcmdldCwgQyk7XG4gICAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZihUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKXtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgcmVkZWZpbmUgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIG1ldGEgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGFzc2lnbiAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKVxuICAsIHdlYWsgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRXZWFrICAgICAgPSBtZXRhLmdldFdlYWtcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlXG4gICwgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZVxuICAsIHRtcCAgICAgICAgICA9IHt9XG4gICwgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKXtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIGlmKGlzT2JqZWN0KGtleSkpe1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrTWFwJywgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlcik7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIHByb3RvICA9ICRXZWFrTWFwLnByb3RvdHlwZVxuICAgICAgLCBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZihpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKXtcbiAgICAgICAgaWYoIXRoaXMuX2YpdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGdldFdlYWsgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWtcbiAgLCBhbk9iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAsICRoYXMgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBhcnJheUZpbmQgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICwgYXJyYXlGaW5kSW5kZXggICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAsIGlkICAgICAgICAgICAgICAgID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKHRoYXQpe1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbihzdG9yZSwga2V5KXtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24oaXQpe1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYofmluZGV4KXRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcylbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcykuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmKGRhdGEgPT09IHRydWUpdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1dlYWtTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0eXBlZCAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBidWZmZXIgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAsIGFuT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JbmRleCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBBcnJheUJ1ZmZlciAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlclxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAsICREYXRhVmlldyAgICA9IGJ1ZmZlci5EYXRhVmlld1xuICAsICRpc1ZpZXcgICAgICA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3XG4gICwgJHNsaWNlICAgICAgID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZVxuICAsIFZJRVcgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICwgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHtBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCl7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKXtcbiAgICBpZigkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZClyZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiAgICA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGhcbiAgICAgICwgZmlyc3QgID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICAgLCBmaW5hbCAgPSB0b0luZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pXG4gICAgICAsIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbmFsIC0gZmlyc3QpKVxuICAgICAgLCB2aWV3UyAgPSBuZXcgJERhdGFWaWV3KHRoaXMpXG4gICAgICAsIHZpZXdUICA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIHdoaWxlKGZpcnN0IDwgZmluYWwpe1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBUWVBFRCAgPSB1aWQoJ3R5cGVkX2FycmF5JylcbiAgLCBWSUVXICAgPSB1aWQoJ3ZpZXcnKVxuICAsIEFCViAgICA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpXG4gICwgQ09OU1RSID0gQUJWXG4gICwgaSA9IDAsIGwgPSA5LCBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUoaSA8IGwpe1xuICBpZihUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKXtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiAgICBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogIFRZUEVELFxuICBWSUVXOiAgIFZJRVdcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICR0eXBlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHRvSW50ZWdlciAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdPUE4gICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgYXJyYXlGaWxsICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBBUlJBWV9CVUZGRVIgICA9ICdBcnJheUJ1ZmZlcidcbiAgLCBEQVRBX1ZJRVcgICAgICA9ICdEYXRhVmlldydcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgV1JPTkdfTEVOR1RIICAgPSAnV3JvbmcgbGVuZ3RoISdcbiAgLCBXUk9OR19JTkRFWCAgICA9ICdXcm9uZyBpbmRleCEnXG4gICwgJEFycmF5QnVmZmVyICAgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXVxuICAsICREYXRhVmlldyAgICAgID0gZ2xvYmFsW0RBVEFfVklFV11cbiAgLCBNYXRoICAgICAgICAgICA9IGdsb2JhbC5NYXRoXG4gICwgUmFuZ2VFcnJvciAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAsIEluZmluaXR5ICAgICAgID0gZ2xvYmFsLkluZmluaXR5XG4gICwgQmFzZUJ1ZmZlciAgICAgPSAkQXJyYXlCdWZmZXJcbiAgLCBhYnMgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgcG93ICAgICAgICAgICAgPSBNYXRoLnBvd1xuICAsIGZsb29yICAgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGxvZyAgICAgICAgICAgID0gTWF0aC5sb2dcbiAgLCBMTjIgICAgICAgICAgICA9IE1hdGguTE4yXG4gICwgQlVGRkVSICAgICAgICAgPSAnYnVmZmVyJ1xuICAsIEJZVEVfTEVOR1RIICAgID0gJ2J5dGVMZW5ndGgnXG4gICwgQllURV9PRkZTRVQgICAgPSAnYnl0ZU9mZnNldCdcbiAgLCAkQlVGRkVSICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUlxuICAsICRMRU5HVEggICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEhcbiAgLCAkT0ZGU0VUICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24odmFsdWUsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpXG4gICAgLCBlTGVuICAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgID0gZU1heCA+PiAxXG4gICAgLCBydCAgICAgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBzICAgICAgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwXG4gICAgLCBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSlcbiAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KXtcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSl7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYodmFsdWUgKiBjID49IDIpe1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gZU1heCl7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGVMZW4gID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAsIG5CaXRzID0gZUxlbiAtIDdcbiAgICAsIGkgICAgID0gbkJ5dGVzIC0gMVxuICAgICwgcyAgICAgPSBidWZmZXJbaS0tXVxuICAgICwgZSAgICAgPSBzICYgMTI3XG4gICAgLCBtO1xuICBzID4+PSA3O1xuICBmb3IoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvcig7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmKGUgPT09IDApe1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZihlID09PSBlTWF4KXtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbnZhciB1bnBhY2tJMzIgPSBmdW5jdGlvbihieXRlcyl7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufTtcbnZhciBwYWNrSTggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn07XG52YXIgcGFja0kxNiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn07XG52YXIgcGFja0kzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59O1xudmFyIHBhY2tGNjQgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufTtcbnZhciBwYWNrRjMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihDLCBrZXksIGludGVybmFsKXtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfX0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG52YXIgc2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKXN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMgPSBmdW5jdGlvbih0aGF0LCBsZW5ndGgpe1xuICBhbkluc3RhbmNlKHRoYXQsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgdmFyIG51bWJlckxlbmd0aCA9ICtsZW5ndGhcbiAgICAsIGJ5dGVMZW5ndGggICA9IHRvTGVuZ3RoKG51bWJlckxlbmd0aCk7XG4gIGlmKG51bWJlckxlbmd0aCAhPSBieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuXG5pZighJHR5cGVkLkFCVil7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5fYiAgICAgICA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXVxuICAgICAgLCBvZmZzZXQgICAgICAgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZihvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYoREVTQ1JJUFRPUlMpe1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZighZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyOyAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlciguNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pKXtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgKXtcbiAgICAgIGlmKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSloaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH07XG4gICAgaWYoIUxJQlJBUlkpQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpXG4gICAgLCAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZih2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSlyZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIid1c2Ugc3RyaWN0JztcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpe1xuICB2YXIgTElCUkFSWSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAgICwgZ2xvYmFsICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICAgLCBmYWlscyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAgICwgJGV4cG9ydCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICAgLCAkdHlwZWQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAgICwgJGJ1ZmZlciAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpXG4gICAgLCBjdHggICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgICAsIGFuSW5zdGFuY2UgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICAgLCBwcm9wZXJ0eURlc2MgICAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICAgLCBoaWRlICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICAgLCByZWRlZmluZUFsbCAgICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgICAsIHRvSW50ZWdlciAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgICAsIHRvTGVuZ3RoICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAgICwgdG9JbmRleCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgICAsIHRvUHJpbWl0aXZlICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAgICwgaGFzICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICAgLCBzYW1lICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpXG4gICAgLCBjbGFzc29mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICAgLCBpc09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgICAsIHRvT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAgICwgaXNBcnJheUl0ZXIgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAgICwgY3JlYXRlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAgICwgZ2V0UHJvdG90eXBlT2YgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAgICwgZ09QTiAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAgICwgZ2V0SXRlckZuICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgICAsIHVpZCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAgICwgd2tzICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICAgLCBjcmVhdGVBcnJheU1ldGhvZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICAgLCBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKVxuICAgICwgc3BlY2llc0NvbnN0cnVjdG9yICA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAgICwgQXJyYXlJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJylcbiAgICAsIEl0ZXJhdG9ycyAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAgICwgJGl0ZXJEZXRlY3QgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgICAsIHNldFNwZWNpZXMgICAgICAgICAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICAgLCBhcnJheUZpbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpXG4gICAgLCBhcnJheUNvcHlXaXRoaW4gICAgID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKVxuICAgICwgJERQICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICAgLCAkR09QRCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAgICwgZFAgICAgICAgICAgICAgICAgICA9ICREUC5mXG4gICAgLCBnT1BEICAgICAgICAgICAgICAgID0gJEdPUEQuZlxuICAgICwgUmFuZ2VFcnJvciAgICAgICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXG4gICAgLCBUeXBlRXJyb3IgICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAgICwgVWludDhBcnJheSAgICAgICAgICA9IGdsb2JhbC5VaW50OEFycmF5XG4gICAgLCBBUlJBWV9CVUZGRVIgICAgICAgID0gJ0FycmF5QnVmZmVyJ1xuICAgICwgU0hBUkVEX0JVRkZFUiAgICAgICA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSXG4gICAgLCBCWVRFU19QRVJfRUxFTUVOVCAgID0gJ0JZVEVTX1BFUl9FTEVNRU5UJ1xuICAgICwgUFJPVE9UWVBFICAgICAgICAgICA9ICdwcm90b3R5cGUnXG4gICAgLCBBcnJheVByb3RvICAgICAgICAgID0gQXJyYXlbUFJPVE9UWVBFXVxuICAgICwgJEFycmF5QnVmZmVyICAgICAgICA9ICRidWZmZXIuQXJyYXlCdWZmZXJcbiAgICAsICREYXRhVmlldyAgICAgICAgICAgPSAkYnVmZmVyLkRhdGFWaWV3XG4gICAgLCBhcnJheUZvckVhY2ggICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMClcbiAgICAsIGFycmF5RmlsdGVyICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgyKVxuICAgICwgYXJyYXlTb21lICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpXG4gICAgLCBhcnJheUV2ZXJ5ICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNClcbiAgICAsIGFycmF5RmluZCAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAgICwgYXJyYXlGaW5kSW5kZXggICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICAgLCBhcnJheUluY2x1ZGVzICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKVxuICAgICwgYXJyYXlJbmRleE9mICAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpXG4gICAgLCBhcnJheVZhbHVlcyAgICAgICAgID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzXG4gICAgLCBhcnJheUtleXMgICAgICAgICAgID0gQXJyYXlJdGVyYXRvcnMua2V5c1xuICAgICwgYXJyYXlFbnRyaWVzICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXNcbiAgICAsIGFycmF5TGFzdEluZGV4T2YgICAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mXG4gICAgLCBhcnJheVJlZHVjZSAgICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2VcbiAgICAsIGFycmF5UmVkdWNlUmlnaHQgICAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0XG4gICAgLCBhcnJheUpvaW4gICAgICAgICAgID0gQXJyYXlQcm90by5qb2luXG4gICAgLCBhcnJheVNvcnQgICAgICAgICAgID0gQXJyYXlQcm90by5zb3J0XG4gICAgLCBhcnJheVNsaWNlICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZVxuICAgICwgYXJyYXlUb1N0cmluZyAgICAgICA9IEFycmF5UHJvdG8udG9TdHJpbmdcbiAgICAsIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nXG4gICAgLCBJVEVSQVRPUiAgICAgICAgICAgID0gd2tzKCdpdGVyYXRvcicpXG4gICAgLCBUQUcgICAgICAgICAgICAgICAgID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICAgLCBUWVBFRF9DT05TVFJVQ1RPUiAgID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpXG4gICAgLCBERUZfQ09OU1RSVUNUT1IgICAgID0gdWlkKCdkZWZfY29uc3RydWN0b3InKVxuICAgICwgQUxMX0NPTlNUUlVDVE9SUyAgICA9ICR0eXBlZC5DT05TVFJcbiAgICAsIFRZUEVEX0FSUkFZICAgICAgICAgPSAkdHlwZWQuVFlQRURcbiAgICAsIFZJRVcgICAgICAgICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAgICwgV1JPTkdfTEVOR1RIICAgICAgICA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uKE8sIGxlbmd0aCl7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciBzdHJpY3RUb0xlbmd0aCA9IGZ1bmN0aW9uKGl0LCBTQU1FKXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHZhciBudW1iZXIgPSAraXRcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoaXQpO1xuICAgIGlmKFNBTUUgJiYgIXNhbWUobnVtYmVyLCBsZW5ndGgpKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9O1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uKGl0LCBCWVRFUyl7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUyl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbihpdCl7XG4gICAgaWYoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KXJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uKEMsIGxlbmd0aCl7XG4gICAgaWYoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uKE8sIGxpc3Qpe1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24oQywgbGlzdCl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gbGlzdC5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihpdCwga2V5LCBpbnRlcm5hbCl7XG4gICAgZFAoaXQsIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9fSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyosIG1hcGZuLCB0aGlzQXJnICovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KHNvdXJjZSlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKyl7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZihtYXBwaW5nICYmIGFMZW4gPiAyKW1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvcihpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspe1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyouLi5pdGVtcyovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCl7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qLCBlbmQgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQsIGVuZCAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCl7XG4gICAgICB2YXIgdGhhdCAgID0gdGhpc1xuICAgICAgICAsIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aFxuICAgICAgICAsIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMilcbiAgICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAgICwgdmFsdWU7XG4gICAgICB3aGlsZShpbmRleCA8IG1pZGRsZSl7XG4gICAgICAgIHZhbHVlICAgICAgICAgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKXtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKXtcbiAgICAgIHZhciBPICAgICAgPSB2YWxpZGF0ZSh0aGlzKVxuICAgICAgICAsIGxlbmd0aCA9IE8ubGVuZ3RoXG4gICAgICAgICwgJGJlZ2luID0gdG9JbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKXtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiwgb2Zmc2V0ICovKXtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKVxuICAgICAgLCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgICAgLCBzcmMgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgaWYobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZShpbmRleCA8IGxlbil0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCl7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpe1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCl7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2Mpe1xuICAgIGlmKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApe1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2UgcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZighQUxMX0NPTlNUUlVDVE9SUyl7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mICAgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogICAgICAgICAgICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmKGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKXtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogICAgICAgICAgJHNsaWNlLFxuICAgIHNldDogICAgICAgICAgICAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiAgICBmdW5jdGlvbigpeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6ICAgICAgIGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpe1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgICAgICAgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSdcbiAgICAgICwgSVNOVF9VSU5UOCA9IE5BTUUgIT0gJ1VpbnQ4QXJyYXknXG4gICAgICAsIEdFVFRFUiAgICAgPSAnZ2V0JyArIEtFWVxuICAgICAgLCBTRVRURVIgICAgID0gJ3NldCcgKyBLRVlcbiAgICAgICwgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXVxuICAgICAgLCBCYXNlICAgICAgID0gVHlwZWRBcnJheSB8fCB7fVxuICAgICAgLCBUQUMgICAgICAgID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KVxuICAgICAgLCBGT1JDRUQgICAgID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlZcbiAgICAgICwgTyAgICAgICAgICA9IHt9XG4gICAgICAsIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4LCB2YWx1ZSl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZihDTEFNUEVEKXZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZihGT1JDRUQpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAgICAgLCBvZmZzZXQgPSAwXG4gICAgICAgICAgLCBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSl7XG4gICAgICAgICAgbGVuZ3RoICAgICA9IHN0cmljdFRvTGVuZ3RoKGRhdGEsIHRydWUpXG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciAgICAgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUil7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKCRsZW4gJSBCWVRFUyl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggPCAwKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbil0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpe1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUoaW5kZXggPCBsZW5ndGgpYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYoISRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpe1xuICAgICAgLy8gVjggd29ya3Mgd2l0aCBpdGVyYXRvcnMsIGJ1dCBmYWlscyBpbiBtYW55IG90aGVyIGNhc2VzXG4gICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDU1MlxuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpcmV0dXJuIG5ldyBCYXNlKHN0cmljdFRvTGVuZ3RoKGRhdGEsIElTTlRfVUlOVDgpKTtcbiAgICAgICAgaWYoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUil7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighKGtleSBpbiBUeXBlZEFycmF5KSloaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmKCFMSUJSQVJZKVR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yICAgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXVxuICAgICAgLCBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpXG4gICAgICAsICRpdGVyYXRvciAgICAgICAgID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZihDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpe1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTLFxuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZighKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKWhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7c2V0OiAkc2V0fSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpLCBOQU1FLCB7dG9TdHJpbmc6IGFycmF5VG9TdHJpbmd9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHtzbGljZTogJHNsaWNlfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKVxuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7dG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ30pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKWhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCByQXBwbHkgICAgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHlcbiAgLCBmQXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByQXBwbHkoZnVuY3Rpb24oKXt9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpXG4gICAgICAsIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYmluZCAgICAgICA9IHJlcXVpcmUoJy4vX2JpbmQnKVxuICAsIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24oKXt9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24oKXt9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyosIG5ld1RhcmdldCovKXtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZihBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmKFRhcmdldCA9PSBuZXdUYXJnZXQpe1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQ7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvICAgID0gbmV3VGFyZ2V0LnByb3RvdHlwZVxuICAgICAgLCBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAsIHJlc3VsdCAgID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHt2YWx1ZTogMX0pLCAxLCB7dmFsdWU6IDJ9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwiLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXSAgICAgICAvLyBrZXlzXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gaXRlcmF0ZWQpa2V5cy5wdXNoKGtleSk7XG59O1xucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCA9IHRoaXNcbiAgICAsIGtleXMgPSB0aGF0Ll9rXG4gICAgLCBrZXk7XG4gIGRvIHtcbiAgICBpZih0aGF0Ll9pID49IGtleXMubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIH0gd2hpbGUoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG4gIHJldHVybiB7dmFsdWU6IGtleSwgZG9uZTogZmFsc2V9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KXtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleS8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cbiAgICAsIGRlc2MsIHByb3RvO1xuICBpZihhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcilyZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSlyZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSlyZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7Z2V0OiBnZXR9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCl7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7b3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBSZWZsZWN0ICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICB2YXIga2V5cyAgICAgICA9IGdPUE4uZihhbk9iamVjdChpdCkpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZigkcHJldmVudEV4dGVuc2lvbnMpJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxuICAgICwgb3duRGVzYyAgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXG4gICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZighb3duRGVzYyl7XG4gICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xuICAgIGlmKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge3NldDogc2V0fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzIiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmKHNldFByb3RvKSRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pe1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgcmVwZWF0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpe1xuICB2YXIgUyAgICAgICAgICAgID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgLCBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aFxuICAgICwgZmlsbFN0ciAgICAgID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpXG4gICAgLCBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZihpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoXG4gICAgLCBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKXN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzUmVnRXhwICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBnZXRGbGFncyAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbihyZWdleHAsIHN0cmluZyl7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCl7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHt2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCl7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZighaXNSZWdFeHAocmVnZXhwKSl0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgICAgID0gU3RyaW5nKHRoaXMpXG4gICAgICAsIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApXG4gICAgICAsIHJ4ICAgID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBvd25LZXlzICAgICAgICA9IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICAgLCBnZXREZXNjID0gZ09QRC5mXG4gICAgICAsIGtleXMgICAgPSBvd25LZXlzKE8pXG4gICAgICAsIHJlc3VsdCAgPSB7fVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiBpKWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5ID0ga2V5c1tpKytdLCBnZXREZXNjKE8sIGtleSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCl7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgaXNFbnVtICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzRW50cmllcyl7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdChpdClcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IFtdXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpe1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KXtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7Z2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24oKXsgLyogZW1wdHkgKi99KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge3NldDogYUZ1bmN0aW9uKHNldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELmdldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuc2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBmcm9tICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpe1xuICAgIGlmKGNsYXNzb2YodGhpcykgIT0gTkFNRSl0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7Z2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvZiAgICAgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCl7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+Pj4gMTZcbiAgICAgICwgdjEgPSAkdiA+Pj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHtkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsInZhciBNYXAgICAgID0gcmVxdWlyZSgnLi9lczYubWFwJylcbiAgLCAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaGFyZWQgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJylcbiAgLCBzdG9yZSAgID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKXtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmKCF0YXJnZXRNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmKCFrZXlNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCl7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKVxuICAgICwga2V5cyAgICAgICAgPSBbXTtcbiAgaWYobWV0YWRhdGFNYXApbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbihfLCBrZXkpeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24oTyl7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwXG4gICwgc3RvcmUgICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoe2RlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICB2YXIgdGFyZ2V0S2V5ICAgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pXG4gICAgLCBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpcmV0dXJuIGZhbHNlO1xuICBpZihtZXRhZGF0YU1hcC5zaXplKXJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ2YXIgU2V0ICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2VzNi5zZXQnKVxuICAsIGZyb20gICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpXG4gICwgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKE8sIFApe1xuICB2YXIgb0tleXMgID0gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUClcbiAgICAsIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZihwYXJlbnQgPT09IG51bGwpcmV0dXJuIG9LZXlzO1xuICB2YXIgcEtleXMgID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn19KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7aGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7bWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSl7XG4gICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShcbiAgICAgIG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLFxuICAgICAgKHRhcmdldEtleSAhPT0gdW5kZWZpbmVkID8gYW5PYmplY3QgOiBhRnVuY3Rpb24pKHRhcmdldCksXG4gICAgICB0b01ldGFLZXkodGFyZ2V0S2V5KVxuICAgICk7XG4gIH07XG59fSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBwcm9jZXNzICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wcm9jZXNzXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBtaWNyb3Rhc2sgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBPQlNFUlZBQkxFICA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJylcbiAgLCBhRnVuY3Rpb24gICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgUkVUVVJOICAgICAgPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihmbil7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmKGNsZWFudXApe1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcil7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCAgICAgID0gc3Vic2NyaWJlcihvYnNlcnZlcilcbiAgICAgICwgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZihjbGVhbnVwICE9IG51bGwpe1xuICAgICAgaWYodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpY2xlYW51cCA9IGZ1bmN0aW9uKCl7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9IGlmKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSljbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTsgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmKG0pcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYoIW0pdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcil7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpe1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbil7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0IDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCl7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZihmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24oaXQpe1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTilyZXR1cm47XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIGlmKGRvbmUpdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpe1xuICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IEFycmF5KGwpOyBpIDwgbDspaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7T2JzZXJ2YWJsZTogJE9ic2VydmFibGV9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIHBhcnRpYWwgICAgPSByZXF1aXJlKCcuL19wYXJ0aWFsJylcbiAgLCBuYXZpZ2F0b3IgID0gZ2xvYmFsLm5hdmlnYXRvclxuICAsIE1TSUUgICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbilcbiAgICApLCB0aW1lKTtcbiAgfSA6IHNldDtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogIHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhdGggICAgICA9IHJlcXVpcmUoJy4vX3BhdGgnKVxuICAsIGludm9rZSAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigvKiAuLi5wYXJncyAqLyl7XG4gIHZhciBmbiAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIHBhcmdzICA9IEFycmF5KGxlbmd0aClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIF8gICAgICA9IHBhdGguX1xuICAgICwgaG9sZGVyID0gZmFsc2U7XG4gIHdoaWxlKGxlbmd0aCA+IGkpaWYoKHBhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKWhvbGRlciA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaiA9IDAsIGsgPSAwLCBhcmdzO1xuICAgIGlmKCFob2xkZXIgJiYgIWFMZW4pcmV0dXJuIGludm9rZShmbiwgcGFyZ3MsIHRoYXQpO1xuICAgIGFyZ3MgPSBwYXJncy5zbGljZSgpO1xuICAgIGlmKGhvbGRlcilmb3IoO2xlbmd0aCA+IGo7IGorKylpZihhcmdzW2pdID09PSBfKWFyZ3Nbal0gPSBhcmd1bWVudHNbaysrXTtcbiAgICB3aGlsZShhTGVuID4gaylhcmdzLnB1c2goYXJndW1lbnRzW2srK10pO1xuICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFydGlhbC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhdGguanMiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHRhc2sgICA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsInZhciAkaXRlcmF0b3JzICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAsIHJlZGVmaW5lICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHdrcyAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIElURVJBVE9SICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgLCBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICwgQXJyYXlWYWx1ZXMgICA9IEl0ZXJhdG9ycy5BcnJheTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgLCBrZXk7XG4gIGlmKHByb3RvKXtcbiAgICBpZighcHJvdG9bSVRFUkFUT1JdKWhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYoIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGZvcihrZXkgaW4gJGl0ZXJhdG9ycylpZighcHJvdG9ba2V5XSlyZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsLnByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLnByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBnbG9iYWwucHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmUgICAgID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7ZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpeyByZXR1cm4gJHJlKGl0KTsgfX0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuMy40XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cblxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcG9zc2libGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICByZXR1cm4gYSA9PT0gYlxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG4gICAgICA/IHZtXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgICA6IHZtLm5hbWU7XG5cbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICB2YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9ICkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuICBpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgY2hpbGQuZGF0YSAmJiBjaGlsZC5kYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlc1xuKSB7XG4gIHJlcyA9IHJlcyB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG4gICAgICAgIHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlZkVsbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gRE9NIG5vZGVzIChwcmV2ZW50cyBsZWFrKVxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IC8vIGhhcyBuZXcgc2NvcGVkIHNsb3RzXG4gICAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0ge1xuICBrZXk6IDEsXG4gIHJlZjogMSxcbiAgc2xvdDogMVxufTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0gfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyAoa2V5c1tpXSkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICAgIGdldHRlciA9IG5vb3A7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfVxuICApO1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcbiAgICBfY29tcG9uZW50VGFnOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcbiAgICBfcmVuZGVyQ2hpbGRyZW46IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbixcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9XG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgaWYgKGlzRGVmKG9uW2V2ZW50XSkpIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2RlcyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3Bcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgcGx1Z2luLmluc3RhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwXTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi4zLjQnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGcm9tRGF0YSAoZGF0YSkge1xuICB2YXIgZHluYW1pY0NsYXNzID0gZGF0YS5jbGFzcztcbiAgdmFyIHN0YXRpY0NsYXNzID0gZGF0YS5zdGF0aWNDbGFzcztcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoaXNVbmRlZih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaXNEZWYodmFsdWVbaV0pKSB7XG4gICAgICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHsgcmVzICs9IGtleSArICcgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cblxuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgaWYgKHJlZi5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuXG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cblxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIHN0cjtcbnZhciBpbmRleCQxO1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2xleSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkQ2hpbGQgJiYgb2xkQ2hpbGQuZGF0YSAmJiAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbm1vZHVsZS5leHBvcnRzID0gVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmNvbW1vbi5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyB0aGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIgLyogc2VydmVyIG9ubHkgKi9cbikge1xuICB2YXIgZXNNb2R1bGVcbiAgdmFyIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2YgcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXNNb2R1bGUgPSByYXdTY3JpcHRFeHBvcnRzXG4gICAgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBjb21waWxlZFRlbXBsYXRlLnJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWRUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIHZhciBmdW5jdGlvbmFsID0gb3B0aW9ucy5mdW5jdGlvbmFsXG4gICAgdmFyIGV4aXN0aW5nID0gZnVuY3Rpb25hbFxuICAgICAgPyBvcHRpb25zLnJlbmRlclxuICAgICAgOiBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgIGlmICghZnVuY3Rpb25hbCkge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlc01vZHVsZTogZXNNb2R1bGUsXG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMzAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCdcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IFRhYiBmcm9tICcuLi9jb21wb25lbnRzL3RhYi52dWUnXG5pbXBvcnQgQXN5bmNDb21wdXRlZCBmcm9tICd2dWUtYXN5bmMtY29tcHV0ZWQnXG5cblZ1ZS51c2UoQXN5bmNDb21wdXRlZClcblxuY29uc3QgYXBwID0gbmV3IFZ1ZSh7XG4gIGVsOiAnI2FwcCcsXG4gIHJlbmRlciAoaCkge1xuICAgIHJldHVybiAoXG4gICAgICA8VGFiIC8+XG4gICAgKVxuICB9XG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL3NjcmlwdHMvdGFiLmpzIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3RhYi52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LThmZGIzYzBhXFxcIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3RhYi52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9yYWNoZWwta2lsbGFja2V5L0Rlc2t0b3AvTGF1bmNoUGFkL2ludGVybmFsL2ZvdG9mbHVlbnQvYXBwL2NvbXBvbmVudHMvdGFiLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gdGFiLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi04ZmRiM2MwYVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LThmZGIzYzBhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvY29tcG9uZW50cy90YWIudnVlXG4vLyBtb2R1bGUgaWQgPSAzMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiPHRlbXBsYXRlPlxuICA8cD5IZWxsbyE8L3A+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgLy8gbmFtZTogJ3RhYidcbiAgfVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdGFiLnZ1ZT81ZTYwZTcxYyIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygncCcsIFtfdm0uX3YoXCJIZWxsbyFcIildKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi04ZmRiM2MwYVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LThmZGIzYzBhXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9hcHAvY29tcG9uZW50cy90YWIudnVlXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnbW9kdWxlJywgJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KG1vZHVsZSwgZXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZCwgbW9kLmV4cG9ydHMpO1xuICAgIGdsb2JhbC5Bc3luY0NvbXB1dGVkID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICB2YXIgcHJlZml4ID0gJ19hc3luY19jb21wdXRlZCQnO1xuXG4gIHZhciBBc3luY0NvbXB1dGVkID0ge1xuICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlLCBwbHVnaW5PcHRpb25zKSB7XG4gICAgICBwbHVnaW5PcHRpb25zID0gcGx1Z2luT3B0aW9ucyB8fCB7fTtcblxuICAgICAgVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMuYXN5bmNDb21wdXRlZCA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzLmNvbXB1dGVkO1xuXG4gICAgICBWdWUubWl4aW4oe1xuICAgICAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgICB2YXIgb3B0aW9uRGF0YSA9IHRoaXMuJG9wdGlvbnMuZGF0YTtcblxuICAgICAgICAgIGlmICghdGhpcy4kb3B0aW9ucy5jb21wdXRlZCkgdGhpcy4kb3B0aW9ucy5jb21wdXRlZCA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuJG9wdGlvbnMuYXN5bmNDb21wdXRlZCB8fCB7fSkge1xuICAgICAgICAgICAgdGhpcy4kb3B0aW9ucy5jb21wdXRlZFtwcmVmaXggKyBrZXldID0gZ2V0dGVyRm9yKHRoaXMuJG9wdGlvbnMuYXN5bmNDb21wdXRlZFtrZXldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiRvcHRpb25zLmRhdGEgPSBmdW5jdGlvbiB2dWVBc3luY0NvbXB1dGVkSW5qZWN0ZWREYXRhRm4oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9ICh0eXBlb2Ygb3B0aW9uRGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbkRhdGEuY2FsbCh0aGlzKSA6IG9wdGlvbkRhdGEpIHx8IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiB0aGlzLiRvcHRpb25zLmFzeW5jQ29tcHV0ZWQgfHwge30pIHtcbiAgICAgICAgICAgICAgZGF0YVtfa2V5XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy4kb3B0aW9ucy5hc3luY0NvbXB1dGVkIHx8IHt9KSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBkZWZhdWx0Rm9yLmNhbGwodGhpcywgdGhpcy4kb3B0aW9ucy5hc3luY0NvbXB1dGVkW2tleV0sIHBsdWdpbk9wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9rZXkyKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZUlkID0gMDtcbiAgICAgICAgICAgIF90aGlzLiR3YXRjaChwcmVmaXggKyBfa2V5MiwgZnVuY3Rpb24gKG5ld1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgdmFyIHRoaXNQcm9taXNlID0gKytwcm9taXNlSWQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFuZXdQcm9taXNlIHx8ICFuZXdQcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5ld1Byb21pc2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3UHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzUHJvbWlzZSAhPT0gcHJvbWlzZUlkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgX3RoaXNbX2tleTJdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1Byb21pc2UgIT09IHByb21pc2VJZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbk9wdGlvbnMuZXJyb3JIYW5kbGVyID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBwbHVnaW5PcHRpb25zLmVycm9ySGFuZGxlciA9PT0gdW5kZWZpbmVkID8gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUsICdFcnJvciBldmFsdWF0aW5nIGFzeW5jIGNvbXB1dGVkIHByb3BlcnR5OicpIDogcGx1Z2luT3B0aW9ucy5lcnJvckhhbmRsZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luT3B0aW9ucy51c2VSYXdFcnJvcikge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlcihlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVyKGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHsgaW1tZWRpYXRlOiB0cnVlIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5MiBpbiB0aGlzLiRvcHRpb25zLmFzeW5jQ29tcHV0ZWQgfHwge30pIHtcbiAgICAgICAgICAgIF9sb29wKF9rZXkyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXR0ZXJGb3IoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZm47XG5cbiAgICB2YXIgZ2V0dGVyID0gZm4uZ2V0O1xuXG4gICAgaWYgKGZuLmhhc093blByb3BlcnR5KCd3YXRjaCcpKSB7XG4gICAgICBnZXR0ZXIgPSBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgIGZuLndhdGNoLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiBmbi5nZXQuY2FsbCh0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBnZXR0ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Rm9yKGZuLCBwbHVnaW5PcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICBpZiAoJ2RlZmF1bHQnIGluIGZuKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSBmbi5kZWZhdWx0O1xuICAgIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHBsdWdpbk9wdGlvbnMpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHBsdWdpbk9wdGlvbnMuZGVmYXVsdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZS5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuZGVmYXVsdCA9IEFzeW5jQ29tcHV0ZWQ7XG5cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICAvLyBBdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG4gICAgd2luZG93LlZ1ZS51c2UoQXN5bmNDb21wdXRlZCk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZS1hc3luYy1jb21wdXRlZC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==